{"meta":{"title":"欢迎来到数学的世界","subtitle":"我走的很慢，但我每一步都走的很稳","description":"欢迎参观我的网站，这里有我的学习记录，但时间有限，大部分内容都在有道云笔记","author":"刘备备","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-04-08T02:26:58.000Z","updated":"2017-04-08T02:57:27.775Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我，一个刚刚毕业的实习生，热爱数据，热爱钻研，熟悉R，Python语言，会MySQL数据库。理解常用算法原理及应用实现"},{"title":"tags","date":"2018-05-24T02:48:38.997Z","updated":"2017-04-08T01:06:53.672Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2017-04-08T02:27:38.000Z","updated":"2017-04-08T02:27:38.299Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-24T02:48:38.995Z","updated":"2017-04-08T01:06:22.014Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"利用Python调用R语言","slug":"利用Python调用R语言","date":"2017-09-13T06:37:42.000Z","updated":"2017-09-29T00:59:20.140Z","comments":true,"path":"2017/09/13/利用Python调用R语言/","link":"","permalink":"http://yoursite.com/2017/09/13/利用Python调用R语言/","excerpt":"","text":"使用pycharm版本在anaconda环境下安装rpy2模块： 这是比较重要的一般，很多安装失败的原因就是没有很好配置环境变量。 将R目录添加至path环境变量path：D:\\Program Files\\Microsoft\\MRO\\R-3.2.3\\bin\\x64; 将R.dll添加至path环境变量path：D:\\Program Files\\Microsoft\\MRO\\R-3.2.3\\bin\\x64\\R.dll; 设置R_HOME环境变量R_HOME：D:\\Program Files\\Microsoft\\MRO\\R-3.2.3 设置R_USER环境变量R_USER：AdministratorR_USER就是你电脑的用户名，如果没有设置过用户名就是Administrator，可以通过cmd命令行输入 net user查看。 import rpy2.robjects as robjects robjects.r(&apos;pi&apos;)#调用R robjects.r( &apos;&apos;&apos; f &lt;- function(r){pi * r} &apos;&apos;&apos; ) robjects.r[&apos;f&apos;](3)#robjects.r(&quot;f(3)&quot;) print robjects.r(&quot;install.packages(&apos;XML&apos;)&quot;) 对于一些特殊的R对象比如list和matrix，如果python要调去其中的部分数据，可以通过其rx()和rx2()方法操作。对于list，可以查看其name属性，以获得列表个个元素名称。rx()和相当于”[“操作（注意取出的是R的list对象），而rx2()相当于”[[“操作。一个例子： http://blog.sina.com.cn/s/blog_77b74e97010194mw.html 导入R包： from rpy2.robjects.packages import importr # import R&apos;s &quot;base&quot; package base = importr(&apos;base&apos;) base.函数（）可以调用函数 pandas与R语言： import rpy2.robjects as robjects from rpy2.robjects import FloatVector from rpy2.robjects.packages import importr import numpy as np import pandas as pd from rpy2.robjects.packages import importr stats = importr(&apos;stats&apos;) base = importr(&apos;base&apos;) tmp = robjects.r(&quot;mtcars&quot;) name = robjects.r(&quot;colnames(mtcars)&quot;) index = robjects.r(&quot;rownames(mtcars)&quot;) tmp = pd.DataFrame(np.array(tmp).T, index=index, columns=name) #将R中的数据表转为pandas的dataframe类型 yy = FloatVector(tmp[&quot;mpg&quot;].values) #将Python中的对象转为R对象类型 x = FloatVector(tmp[&quot;wt&quot;].values) z= FloatVector(tmp[&quot;cyl&quot;].values) robjects.globalenv[&quot;yy&quot;] = yy #将转化后的对象设置为全局变量 robjects.globalenv[&quot;x&quot;] = x robjects.globalenv[&quot;z&quot;] = z lm_D90 =robjects.r(&quot;lm(yy~x+z)&quot;)#应用R函数 #lm_D9 = stats.lm(&quot;yy~x&quot;) print(base.summary(lm_D90)) print robjects.r(&quot;table(yy,z)&quot;) 可以将python的list对象，转换成为R的vector对象，之后直接使用R函数调用。相应的函数是 robjects.StrVector() robjects.IntVector() robjects.FloatVector() robjects.complexVector() robjects.FactorVector() robjects.BoolVector() 这些函数将python列表转化成R的字符/整数/浮点/复数/因子/布尔向量。robjects.ListVector()将python的字典转换成R的列表。","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"Python-利用Python进行数据分析前五章.md","slug":"Python-利用Python进行数据分析前五章","date":"2017-09-13T06:15:34.000Z","updated":"2017-09-29T01:00:37.734Z","comments":true,"path":"2017/09/13/Python-利用Python进行数据分析前五章/","link":"","permalink":"http://yoursite.com/2017/09/13/Python-利用Python进行数据分析前五章/","excerpt":"","text":"运行.py文件的两种方法 $ Python 文件名.py，％run 文件名 .py。 Python使用空白来组织代码 for x in array: if 条件: 语句 else: 语句 注释#，后面的文本会被解释器注释掉。 变量的引用 x=［1，2，3］ y=x，表示x，y同时指向用一个对象 x.append（4） y 1 2 3 4 和r的区别是函数可以“读写”上层变量，因为是引用，所以可以改。 def hanshu（data，k）: data.append（k）建议缩进4个空格 动态引用，类似r a=2，b=“foo”，type（a）函数。 a+b不会被强制转换，Python是一种强类型语言，但是整数和浮点数例外。 isinstance（a，int╱（int，float）），返回TRUE Python中的对象有属性和方法， a.或getattr（a，“split”） 异常 def hanshu（obj）: try: 语句 except Error: 语句 1，import 函数包，调用包中变量或函数用“包名.函数名” from sm import f，g，PI import sm as ss from sm import f as ff，g 二元运算符与r一样，+，-，╱╱整除，&amp;，|。 比较运算符返回布尔值 额外is，is not，a is b返回布尔值确定a，b是否指向同一引用。 a=［1，2］；b=a；c=list（a） a is c F，a==c T。 可变可不可变，list，［］可以修改，（）不可以修改，元组是不可变的列表，脚标从0开始。 ##标量类型，None表示Null值，str字符串类型，float双精度浮点数，bool布尔值，int有符号整数，long任意精度的有符号整数。 ##字符串，x=“gjjj”，x=“““ hjjkkjggh ””” Python的字符串是不可变的，索引x［5］ x.replace（“ggh”，“hhhhhh”）查找替换函数 Python对象可用str（x）函数转字符串。 字符串转列表元组x=“adf”，y=list（x），y=［“a”，“d”，“f”］ 拼接字符串x+y 转义符\\，加r“a\\b”去除\\的转义意义 布尔值可以用and，or连接，空序列（列表，字典，元组）会被当做F，想知道哪个对象被强制转换成什么布尔值可用bool（x）函数 类型转换str（），bool（），int（），float（）None还是函数参数的一种常见默认值a is None，a is not None ##日期和时间datetime模块，date，time，datetime函数dt=datetime（2013，10，29，10，25，56）， dt.date（），dt.time（），dt.day等 dt.strftime（“％m╱％d╱％y ％H╱％M”） 替换datetime的字段 dt.replace（minute=0，second=0） 两个datetime的差会是一个datetime.timedelta对象。 ##控制流if 条件: if TRUE or flase: 语句 语句 if 条件: 语句elif 条件: 语句else: 语句 for循环，continue跳过余下语句进行下一次迭代，break跳出循环 while循环，while 条件: 语句while 条件： 语句else： 语句 pass，表示Python中的空操作语句，可以被用于没有任何操作的代码块中。 异常处理try: 语句except 异常名字多个用（）: 语句else: 语句，else后面表示没有错误成功执行了后回执的语句。finally: 一定会被执行的语句 range和xrange，含头不含尾range（0，10，2），0 2 4 6 8。range（10），0～9，间隔默认1range常用作按索引对序列进行迭代for i in range（len（x））:对于非常长的范围，用xrange。 ##三元表达式，TRUE if 条件 else flase ##数据结构和序列元组是一种一维的定长的不可变的Python序列，Python创建如下 x=1，2，3，或（1，2，3） x=（（1，2），（3，4，5）） tuple（［1，2］）将其他序列或迭代器转为元组，tuple（“string”），（“s”…） Python中序列是从0开始索引，用［］，不可以改变但是可以追加，如 x=（“string”，［1，2］） x［2］.append（3）元组可以通过“+”来形成更长的元组 对元组乘以一个整数，等于连接该元组多个副本。 ##元组拆包，如tup=（1，2，（3，4）） a，b，（c，d）=tup，则a=1，d=4 变量名转换b，a=a，b 可用作for循环 ##元组方法，x.count（2），对元组中2出现的次数计数，列表也是这函数 ##列表list，变长的可修改通过list（），［］定义，list（）函数可将其他对象转换为列表。 x［2］=56，修改2角标的元素。 添加和移除元素，append（）添加到最后 insert（角标，值）添加指定位置，顺延。 pop（角标）移除指定元素 remove（值）移除查找到的第一个值 in，值 in list返回布尔值，看值是否存在list中 合并列表，“+”号，extend（list）一次添加多个元素，速度快 排序，list.sort（）直接对list排序 字符串长度排序sort（key=len），key=func，该函数应用与序列的每一个元素 sorted（set（data））排序只返回唯一值 ##二分搜索和维护有序列表bisect模块bisect.bisect（list，值）返回新值应插入的位置索引值，能保持原序列的有序性 bisect.insort（list，值）插进去值并保持有序 ##切片，选取序列的子集x［start:end］类似r语言向量，区别是不包含end角标值。x［3:］包含结尾最后一个值 x［-5:-2］，表示从尾开始按0索引取（从尾取，方法类似从头取，含头不含尾） x［::2］步长，表示隔一个数取一个。 x［::-1］实现列表的反序 ##内置的序列函数enumerate（序列）返回序列的（i，value）元组，用作for a，b in enumerate（序列）: sorted（）可以将序列返回一个新的有序序列，字符串按照字符排序 set（“string”）返回为字符串中唯一元素list zip（list，list）对多个序列（list或元组）配对，形成一个配对元组列表，长度由最短的序列决定，可用于for循环和enumerate结合。 for a，b in zip（x，y） 解压，a，b=zip（*x） reversed（序列）逆序迭代序列元素 ##字典dict，又名hash map或相联数组，是大小可变的键值对集，key和value，创建是｛｝用:分割键值。 访问，插入dict［key］ 判断是否存在某个key，key in dict 删除，del dict［key］，dict.pop（key） 获取键或值dict.keys（），dict.values（） dict.update（dict2），合并字典 dict［key］.append（values） ##从序列类型创建字典，dict（zip（x，y））创建key为x，value为y的字典 字典的有效类型 key必须是不可变对象，values可以是任意对象，hash（）测试是否是适合做key，key可以是（1，2） ##集合set，是由唯一元素组成的无序集，可以看做是只有key没有values的字典，创建set（），｛｝ 集合的并a|b，交a&amp;b，差a-b，a∧b异或去掉两个集合都有的。 a.issubset（b）a是否是b的子集 b.issuperset（a）b是否是a的超集 如果两个集合内容相同，顺序不同则a==b是T Python的集合运算 a.add（x），a.remove（x）， a.isdisjoint（b）a，b没有公共元素返回T ##列表和集合，字典的推导式［w.upper（） for w in words if len（w）&gt;2］生成一个满足条件的列表（列表过滤） ##字典推导式｛key:values for key，value in collection if condition｝dict（（key，values） for key，value in collection if condition ） ##集合推导式｛expr for value in collection if condition｝ （if可以省略，如把某列表的字符串长度存为一个集合｛len（x） for x in list｝） ##嵌套列表推导式［［…］，［…］］［name for names in allnames for name in names if name.count（“e”）&gt;2］ ##函数，def，return位置参数和关键字参数，关键字参数表示指定默认值的参数，必须位于位置参数后面。 可以在函数内用global a定义全局变量a return a，b，c 返回多个值元组 return ｛“a”:a，“b”:b｝返回多个值，字典形式 ##函数也是对象，可以被函数调用如fun=［fun1，fun2］ for funn in fun: funn（x） 函数也可以当做另一个函数的参数被调用，和r类似 ##匿名函数lamdba函数x.sort（key=lambda x:len（set（list（x））））按照字符串不同字母数排序 ##闭包，返回函数的函数，即使创建者运行完毕，闭包仍可以访问创建者的局部命名空间。 def fun（a）: def fu（x）: return a（x） return fu使函数参数简单化。 ##args，kwargs扩展调用语法##柯里化，部分参数应用如已有函数funn（x，y） lambda y:funn（5，y），y称为柯里化的 ##生成器，将return改为yield，生成器只有被调用时才会一次一个值的输出，否则返回对象调用地址值。 生成器推导式（xper for x in collection） ##itertools模块，返回为生成器。groupby（collection，fun）根据函数返回值对collection进行分组 imap（fun，iterables）将fun运用与参数序列每个打包元组 ifilter（fun，iterable）当func（x）为TRUE时返回x combinations（iterable，k）生成一个由iterable中所有可能的k元元组组成的序列 permutations（iterable，k）以上类似，但是考虑顺序 文件和操作系统 path=“x╱xx.TXT” f=open（path） 从文件取出行都带有eol行结束符，以下代码得到没有eol的行 ［x.rstrip（） for x in open（path）］ open（path，“r”）只读 “w”，创建新文件，覆盖原来的 “a”，追加到原有文件后 “r+”，读写模式 open（“地址文件”，“w”）.writelines（） .write（str） .readlines（） .read（） .close（） .flush（） .seek（pos）移动到指定文件位置 .closed，如果文件关闭，则为True`","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"cakephp-内置表单函数.md","slug":"cakephp-内置表单函数","date":"2017-08-04T01:53:02.000Z","updated":"2017-08-04T01:57:01.924Z","comments":true,"path":"2017/08/04/cakephp-内置表单函数/","link":"","permalink":"http://yoursite.com/2017/08/04/cakephp-内置表单函数/","excerpt":"","text":"$this-&gt;Form-&gt;create(null,[&apos;type&apos; =&gt; &apos;get&apos;,&apos;context&apos; =&gt; $this-&gt;request-&gt;data, &apos;id&apos; =&gt; &apos;query-conditions&apos;]) //查询常用 不用创建空entity过来 $this-&gt;Form-&gt;create($entity,[&apos;type&apos;=&quot;file&quot;]) $this-&gt;Form-&gt;input(&apos;确定&apos;,[&apos;type&apos;=&gt;&apos;submit&apos;]) $this-&gt;Form-&gt;end() 单选框radio $this-&gt;Form-&gt;input(&quot;name&quot;,[&apos;label&apos;=&gt;false,&apos;value&apos;=&gt;2,&apos;type&apos;=&gt;&apos;radio&apos;,&apos;options&apos; =&gt; Cake\\ORM\\TableRegistry::get(&apos;Consumes&apos;)-&gt;type]) type是一个一维关联数组$type = [1=&gt;&apos;充值&apos;,2=&gt;&apos;冻结&apos;,3=&gt;&apos;配送收入&apos;] 下拉选项框 $this-&gt;Form-&gt;input(&quot;name&quot;,[&apos;label&apos;=&gt;false,&apos;value&apos;=&gt;410100,&apos;options&apos;=&gt; \\Cake\\ORM\\TableRegistry::get(&apos;Areas&apos;)-&gt;cities(&apos;list&apos;)]) $this-&gt;Form-&gt;input(&quot;name&quot;,[&quot;label&quot;=false,&quot;empty&quot;=&quot;请选择&quot;,&quot;options&quot;=&gt;\\Cake\\ ORM\\TableRegistry::get(&quot;table&quot;)-&gt;type]) 普通的文本输入 $this-&gt;Form-&gt;input(&quot;my_file&quot;,[&apos;type&apos;=&quot;file&quot;,&apos;label&apos;=&quot;false&quot;]) type=&quot;textarea/text/password&quot; 查询表单 $this-&gt;Form-&gt;create(&quot;null&quot;,[&quot;type&quot;=&gt;&quot;get&quot;,]) $this-&gt;Form-&gt;text(&quot;name&quot;,[options]) 下拉 $this-&gt;Form-&gt;select(&apos;order_status&apos;,[&apos;1&apos;=&gt;&apos;个人用户&apos;,&apos;2&apos;=&gt;&apos;商家用户&apos;,&apos;3&apos;=&gt;&apos;配 送员&apos;],[&apos;empty&apos;=&gt;&apos;全部&apos;,&apos;class&apos;=&gt;&apos;select-line&apos;]) empty表示默认填充的内容 value=3才是3对应的标签 $this-&gt;Form-&gt;select(&apos;type&apos;, \\Cake\\ORM\\TableRegistry::get(&apos;Consumes&apos;)-&gt;type,[&apos;empty&apos;=&gt;&apos;全部&apos;,&apos; class&apos;=&gt;&apos;select-line&apos;])","categories":[{"name":"cakephp","slug":"cakephp","permalink":"http://yoursite.com/categories/cakephp/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"总结几个实用的R技巧.md","slug":"总结几个实用的R技巧","date":"2017-06-03T08:03:35.000Z","updated":"2017-06-03T09:47:17.774Z","comments":true,"path":"2017/06/03/总结几个实用的R技巧/","link":"","permalink":"http://yoursite.com/2017/06/03/总结几个实用的R技巧/","excerpt":"根据数据的值改变因子水平顺序 - reorder() 下面这个例子将根据count列对spray列中的因子水平进行重排序，汇总数据为mean： reorder函数：首参选定因子向量，次参选定排序依据的数据向量，FUN参数选定汇总函数 iss$spray = reorder(iss$spray, iss$count, FUN = mean) 改变因子水平的名称 - revalue() / mapvalues() in plyr包 如下两行R语言代码均可将水平因子f中名为”small”，”medium”，”large”的因子分别更名为”S”，”M”, “L”： 方法一 f = revalue(f, c(small = &quot;S&quot;, medium = &quot;M&quot;, large = &quot;L&quot;)) 方法二 f=mapvalues(f,c(&quot;small&quot;,&quot;medium&quot;, &quot;large&quot;),c(&quot;S&quot;, &quot;M&quot;,&quot;L&quot;))","text":"根据数据的值改变因子水平顺序 - reorder() 下面这个例子将根据count列对spray列中的因子水平进行重排序，汇总数据为mean： reorder函数：首参选定因子向量，次参选定排序依据的数据向量，FUN参数选定汇总函数 iss$spray = reorder(iss$spray, iss$count, FUN = mean) 改变因子水平的名称 - revalue() / mapvalues() in plyr包 如下两行R语言代码均可将水平因子f中名为”small”，”medium”，”large”的因子分别更名为”S”，”M”, “L”： 方法一 f = revalue(f, c(small = &quot;S&quot;, medium = &quot;M&quot;, large = &quot;L&quot;)) 方法二 f=mapvalues(f,c(&quot;small&quot;,&quot;medium&quot;, &quot;large&quot;),c(&quot;S&quot;, &quot;M&quot;,&quot;L&quot;)) 2.日常问题， as.Date将今天的日期变为昨天，lubridate as.Date(ymd_hms(as.character(as.POSIXct(cancel_dan $pay_time,origin=&quot;1970-01-01 00:00:00&quot;)))) 这样比较准确 3.向数据库传参数查询 conn&lt;-dbConnect()--连接数据库 sql&lt;-“sql 语句” –需要执行的sql语句，注意如果有参数，需要拼接字符串 用paste() dbSendQuery(conn,sql)--把sql语句抛送给数据库执行 4.如何输出txt文件不带 “” f&lt;-file(&quot;C:/Users/Administrator/Desktop/pac.txt&quot;,&quot;a&quot;) write.table(names(z[1]),f,row.names = FALSE,col.names = FALSE,quote = F) close(f) 5.中文转换为繁体 devtools::install_github(&quot;qinwf/ropencc&quot;) library(ropencc) converter(S2T)[&quot;开放中文转换&quot;] [1] &quot;開放中文轉換&quot; 6.如果某行有缺失值返回false complete.cases(y) 7.R调用百度地图api 下载地址 http://download.csdn.net/detail/trueman007/7944319 安装方法： install.packages(&apos;你的目录/RbaiduMaps_0.1.tar.gz&apos;, type=&apos;source&apos;) 运行方法： library(&apos;RbaiduMaps&apos;) 获取地址经纬度： 加载依赖的json解析包 library(&quot;RJSONIO&quot;) getGeoCodeBD(&quot;上海东方明珠&quot;) 函数返回经纬度地址 简单画地图： library(png) mp&lt;-GetMapBD(&quot;上海&quot;,size=c(640,640),zoom=10) PlotOnStaticMapBD(mp) 8.多行删除重复值 data &lt;- data.frame(id1 = c(1, 1, 1, 2, 2), id2 = c(2, 2, 3, 2, 2)) library(dplyr) data %&gt;% group_by(id1, id2) %&gt;% filter(row_number() == 1) %&gt;% ungroup() 9.转时间戳为时间 send_order_01$x&lt;-as.Date(ymd_hms(as.character (as.POSIXct(send_order_01 $confirm_time,origin=&quot;1970-01-01 00:00:00&quot;)))) 10.stopifnot() 该函数当里面的语句返回true时候正常运行，否则报错 stopifnot(length(x)==25)","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"}]},{"title":"python-基础1","slug":"python-基础1","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:01:17.235Z","comments":true,"path":"2017/05/04/python-基础1/","link":"","permalink":"http://yoursite.com/2017/05/04/python-基础1/","excerpt":"","text":"运行.py文件的两种方法 $ Python 文件名.py，％run 文件名 .py。 Python使用空白来组织代码 for x in array: if 条件: 语句 else: 语句 注释#，后面的文本会被解释器注释掉。 变量的引用 x=［1，2，3］ y=x，表示x，y同时指向用一个对象 x.append（4） y 1 2 3 4 和r的区别是函数可以“读写”上层变量，因为是引用，所以可以改。 def hanshu（data，k）: data.append（k）建议缩进4个空格 动态引用，类似r a=2，b=“foo”，type（a）函数。 a+b不会被强制转换，Python是一种强类型语言，但是整数和浮点数例外。 isinstance（a，int╱（int，float）），返回TRUE Python中的对象有属性和方法，a.或getattr（a，“split”） 异常 def hanshu（obj）: try: 语句 except Error: 语句 1，import 函数包，调用包中变量或函数用“包名.函数名” 2，from sm import f，g，PI 3， import sm as ss from sm import f as ff，g 二元运算符与r一样，+，-，╱╱整除，&amp;，|。 比较运算符返回布尔值 额外is，is not，a is b返回布尔值确定a，b是否指向同一引用。 a=［1，2］；b=a；c=list（a） a is c F，a==c T。 可变可不可变，list，［］可以修改，（）不可以修改，元组是不可变的列表，脚标从0开始。 标量类型，None表示Null值，str字符串类型，float双精度浮点数，bool布尔值，int有符号整数，long任意精度的有符号整数。 字符串， x=“gjjj” x=“““ hjjkkjggh ””” Python的字符串是不可变的，索引x［5］ x.replace（“ggh”，“hhhhhh”）查找替换函数 Python对象可用str（x）函数转字符串。 字符串转列表元组x=“adf”，y=list（x），y=［“a”，“d”，“f”］ 拼接字符串x+y 转义符\\，加r“a\\b”去除\\的转义意义 布尔值可以用and，or连接，空序列（列表，字典，元组）会被当做F，想知道哪个对象被强制转换成什么布尔值可用bool（x）函数 类型转换str（），bool（），int（），float（） None还是函数参数的一种常见默认值 a is None，a is not None 日期和时间datetime模块，date，time，datetime函数dt=datetime（2013，10，29，10，25，56），dt.date（），dt.time（），dt.day等 dt.strftime（“％m╱％d╱％y ％H╱％M”） 替换datetime的字段 dt.replace（minute=0，second=0） 两个datetime的差会是一个datetime.timedelta对象。 控制流 if 条件: if TRUE or flase: 语句 语句 if 条件: 语句 elif 条件: 语句 else: 语句 for循环，continue跳过余下语句进行下一次迭代，break跳出循环 while循环， while 条件: 语句 while 条件： 语句 else： 语句 pass，表示Python中的空操作语句，可以被用于没有任何操作的代码块中。 异常处理 try: 语句 except 异常名字多个用（）: 语句 else: 语句，else后面表示没有错误成功执行了后回执的语句。 finally: 一定会被执行的语句 range和xrange，含头不含尾 range（0，10，2），0 2 4 6 8。 range（10），0～9，间隔默认1 range常用作按索引对序列进行迭代 for i in range（len（x））: 对于非常长的范围，用xrange。 三元表达式，TRUE if 条件 else flase 数据结构和序列 元组是一种一维的定长的不可变的Python序列，Python创建如下 x=1，2，3，或（1，2，3） x=（（1，2），（3，4，5）） tuple（［1，2］）将其他序列或迭代器转为元组，tuple（“string”），（“s”…） Python中序列是从0开始索引，用［］，不可以改变但是可以追加，如 x=（“string”，［1，2］） x［2］.append（3） 元组可以通过“+”来形成更长的元组 对元组乘以一个整数，等于连接该元组多个副本。 元组拆包，如 tup=（1，2，（3，4）） a，b，（c，d）=tup，则a=1，d=4 变量名转换b，a=a，b 可用作for循环 元组方法，x.count（2），对元组中2出现的次数计数，列表也是这函数 列表list，变长的可修改通过list（），［］定义，list（）函数可将其他对象转换为列表。 x［2］=56，修改2角标的元素。 添加和移除元素，append（）添加到最后 insert（角标，值）添加指定位置，顺延。 pop（角标）移除指定元素 remove（值）移除查找到的第一个值 in，值 in list返回布尔值，看值是否存在list中 合并列表，“+”号，extend（list）一次添加多个元素，速度快 排序，list.sort（）直接对list排序 字符串长度排序sort（key=len），key=func，该函数应用与序列的每一个元素 sorted（set（data））排序只返回唯一值 二分搜索和维护有序列表bisect模块 bisect.bisect（list，值）返回新值应插入的位置索引值，能保持原序列的有序性 bisect.insort（list，值）插进去值并保持有序 切片，选取序列的子集 x［start:end］类似r语言向量，区别是不包含end角标值。x［3:］包含结尾最后一个值 x［-5:-2］，表示从尾开始按0索引取（从尾取，方法类似从头取，含头不含尾） x［::2］步长，表示隔一个数取一个。 x［::-1］实现列表的反序 内置的序列函数 enumerate（序列）返回序列的（i，value）元组，用作for a，b in enumerate（序列）: sorted（）可以将序列返回一个新的有序序列，字符串按照字符排序 set（“string”）返回为字符串中唯一元素list zip（list，list）对多个序列（list或元组）配对，形成一个配对元组列表，长度由最短的序列决定，可用于for循环和enumerate结合。 for a，b in zip（x，y） 解压，a，b=zip（*x） reversed（序列）逆序迭代序列元素 字典dict，又名hash map或相联数组，是大小可变的键值对集，key和value，创建是｛｝用:分割键值。 访问，插入dict［key］ 判断是否存在某个key，key in dict 删除，del dict［key］，dict.pop（key） 获取键或值dict.keys（），dict.values（） dict.update（dict2），合并字典 dict［key］.append（values） 从序列类型创建字典， dict（zip（x，y））创建key为x，value为y的字典 字典的有效类型，key必须是不可变对象，values可以是任意对象，hash（）测试是否是适合做key，key可以是（1，2） 集合set，是由唯一元素组成的无序集，可以看做是只有key没有values的字典，创建set（），｛｝ 集合的并a|b，交a&amp;b，差a-b，a∧b异或去掉两个集合都有的。 a.issubset（b）a是否是b的子集 b.issuperset（a）b是否是a的超集 如果两个集合内容相同，顺序不同则a==b是T Python的集合运算 a.add（x），a.remove（x）， a.isdisjoint（b）a，b没有公共元素返回T 列表和集合，字典的推导式 ［w.upper（） for w in words if len（w）&gt;2］生成一个满足条件的列表（列表过滤） 字典推导式 ｛key:values for key，value in collection if condition｝ dict（（key，values） for key，value in collection if condition ） 集合推导式 ｛expr for value in collection if condition｝ （if可以省略，如把某列表的字符串长度存为一个集合｛len（x） for x in list｝） 嵌套列表推导式 ［［…］，［…］］ ［name for names in allnames for name in names if name.count（“e”）&gt;2］ 函数，def，return 位置参数和关键字参数，关键字参数表示指定默认值的参数，必须位于位置参数后面。 可以在函数内用global a定义全局变量a return a，b，c 返回多个值元组 return ｛“a”:a，“b”:b｝返回多个值，字典形式 函数也是对象，可以被函数调用如 fun=［fun1，fun2］ for funn in fun: funn（x） 函数也可以当做另一个函数的参数被调用，和r类似 匿名函数lamdba函数 x.sort（key=lambda x:len（set（list（x））））按照字符串不同字母数排序 闭包，返回函数的函数，即使创建者运行完毕，闭包仍可以访问创建者的局部命名空间。 def fun（a）: def fu（x）: return a（x） return fu 使函数参数简单化。 args，kwargs扩展调用语法 柯里化，部分参数应用 如已有函数funn（x，y） lambda y:funn（5，y），y称为柯里化的 生成器，将return改为yield，生成器只有被调用时才会一次一个值的输出，否则返回对象调用地址值。 生成器推导式（xper for x in collection） itertools模块，返回为生成器。 groupby（collection，fun）根据函数返回值对collection进行分组 imap（fun，iterables）将fun运用与参数序列每个打包元组 ifilter（fun，iterable）当func（x）为TRUE时返回x combinations（iterable，k）生成一个由iterable中所有可能的k元元组组成的序列 permutations（iterable，k）以上类似，但是考虑顺序 文件和操作系统 path=“x╱xx.TXT” f=open（path） 从文件取出行都带有eol行结束符，以下代码得到没有eol的行 ［x.rstrip（） for x in open（path）］ open（path，“r”）只读 “w”，创建新文件，覆盖原来的 “a”，追加到原有文件后 “r+”，读写模式 open（“地址文件”，“w”）.writelines（） .write（str） .readlines（） .read（） .close（） .flush（） .seek（pos）移动到指定文件位置 .closed，如果文件关闭，则为True","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-元组","slug":"python-元组","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:02:19.461Z","comments":true,"path":"2017/05/04/python-元组/","link":"","permalink":"http://yoursite.com/2017/05/04/python-元组/","excerpt":"元组是元素不可变的列表 空元组tup=（） 只有一个元素的元组tup=（50，）","text":"元组是元素不可变的列表 空元组tup=（） 只有一个元素的元组tup=（50，） 元组索引切片与list类似 元组不可以修改，但是可以+连接元组 元组中元素不可以删除，但可以删除整个元组 del tup 元组运算符 len（），+，*，in，迭代 元组函数方法 tuple（seq）序列转元组 max（tup），min（tup），len（tup）","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-数字","slug":"python-数字","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:04:34.634Z","comments":true,"path":"2017/05/04/python-数字/","link":"","permalink":"http://yoursite.com/2017/05/04/python-数字/","excerpt":"数值类型不能被改变，如果重新赋值等于重新分配内存空间 del x删除对象引用 数字类型转换int（），float（） 不同数值类型运算会把整形变为浮点型 abs（），fabs（），ceil（），floor（） sqrt（），max（），min（），round（x，n），modf（）返回整数部分和小数部分 pow（x，y）x**y的值","text":"数值类型不能被改变，如果重新赋值等于重新分配内存空间 del x删除对象引用 数字类型转换int（），float（） 不同数值类型运算会把整形变为浮点型 abs（），fabs（），ceil（），floor（） sqrt（），max（），min（），round（x，n），modf（）返回整数部分和小数部分 pow（x，y）x**y的值 随机数函数random模块 choice(x),randrange(x,y),random(),shuffle(x)将x随机排序，uniform（x，y）生成一个实数。 数学常量 pi ，e math模块学习： dir（math），help（math） ceil(x) 取顶 floor(x) 取底 fabs(x) 取绝对值 factorial (x) 阶乘 pow(x,y) x的y次方 sqrt(x) 开平方 log(x) log10(x) trunc(x) 截断取整数部分 isnan (x) 判断是否NaN(not a number) degree (x) 弧度转角度 radians(x) 角度转弧度","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-迭代器","slug":"python-迭代器","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:05:30.754Z","comments":true,"path":"2017/05/04/python-迭代器/","link":"","permalink":"http://yoursite.com/2017/05/04/python-迭代器/","excerpt":"切片： L = [‘Michael’, ‘Sarah’, ‘Tracy’, ‘Bob’, ‘Jack’] L[-2:]#取L的最后一个 [‘Bob’, ‘Jack’] L[-2:-1]#不取L的最后一个","text":"切片： L = [‘Michael’, ‘Sarah’, ‘Tracy’, ‘Bob’, ‘Jack’] L[-2:]#取L的最后一个 [‘Bob’, ‘Jack’] L[-2:-1]#不取L的最后一个[‘Bob’] L[:10:2] [0, 2, 4, 6, 8]#前10个数，每两个取一个 L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]#所有数，每五个取一个 L[:]#原样复制一个list： tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： 字符串’xxx’或Unicode字符串u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 迭代器 iter（）创建迭代器，next（it）输出迭代器的下一个元素，一次输出一个。 迭代器可以for循环遍历 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： from collections import Iterable isinstance(‘abc’, Iterable) 生成器 生成器是一个返回迭代数的函数，简单的说就是在函数的执行过程中，yield语句会把你需要的值返回给调用生成器的地方，然后退出函数，下一次调用生成器函数的时候又从上次中断的地方开始执行，而生成器内的所有变量参数都会被保存下来供下一次使用。 将函数的return换为yield 数据结构 集合 集合，in，notin，set（“string”）自动去掉重复字母 a-b，在集合a中而不在集合b中， a|b，在a或b中 a&amp;b，同时在a中和b中的字母 a**b,去除a&amp;bd的部分 遍历技巧 字典遍历可用dict.items（）同时读出键值 可以用enumerate（seq）方法读取索引值和值 反向遍历，函数reversesd（seq） 排序遍历，可以用sorted（seq)函数先对原序列排序后遍历","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-datatime模块","slug":"python-datatime模块","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:06:40.904Z","comments":true,"path":"2017/05/04/python-datatime模块/","link":"","permalink":"http://yoursite.com/2017/05/04/python-datatime模块/","excerpt":"os模块 os.getcwd()返回当前工作目录 os.chdir（“dir”）更改当前工作目录 dir（os），help（os） glob模块 glob.glob(“*.py”)从当前目录搜索文件 日期和时间：datatime模块 from datetime import date,datetime print datetime.today()","text":"os模块 os.getcwd()返回当前工作目录 os.chdir（“dir”）更改当前工作目录 dir（os），help（os） glob模块 glob.glob(“*.py”)从当前目录搜索文件 日期和时间：datatime模块 from datetime import date,datetime print datetime.today() datetime模块定义了两个常量：datetime.MINYEAR和datetime.MAXYEAR，分别表示datetime所能表示的最小、最大年份。其中，MINYEAR = 1，MAXYEAR = 9999。 •datetime.date：表示日期的类。常用的属性有year, month, day； •datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond； •datetime.datetime：表示日期时间。 •datetime.timedelta：表示时间间隔，即两个时间点之间的长度。 上面的类型对象不可变 1.data类datetime.date date类定义了一些常用的类方法与类属性： date.today()：返回一个表示当前本地日期的date对象； date.max、date.min：date对象所能表示的最大、最小日期； date.fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象； date提供的实例方法和属性： date.year、date.month、date.day：年、月、日； date.replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（now = date(2015,6,10) tomorrow = now.replace(day = 11)） date.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推； data.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推； date.isocalendar()：返回格式如(year，month，day)的元组； date.isoformat()：返回格式如’YYYY-MM-DD’的字符串； date.strftime(fmt)：自定义格式化字符串。 date2 = date1 + timedelta # 日期加上一个间隔，返回一个新的日期对象（timedelta将在下面介绍，表示时间间隔） date2 = date1 - timedelta # 日期隔去间隔，返回一个新的日期对象 timedelta = date1 - date2 # 两个日期相减，返回一个时间间隔对象 date1 &lt; date2 # 两个日期进行比较 2.time类 time类提供的实例方法和属性： time.hour、time.minute、time.second、time.microsecond：时、分、秒、微秒； time.tzinfo：时区信息； time.replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])：创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）； tm.replace(hour = 8) time.isoformat()：返回型如”HH:MM:SS”格式的字符串表示； time.strftime(fmt)：返回自定义格式化字符串。 像date一样，time也可以对两个time对象进行比较，或者相减返回一个时间间隔对象。 3.datatime类： datetime.today()：返回一个表示当前本地时间的datetime对象； datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间； datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息； datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象； datetime.combine(date, time)：根据date和time，创建一个datetime对象； datetime.strptime(date_string, format)：将格式字符串转换为datetime对象； datetime.year、month、day、hour、minute、second、microsecond、tzinfo： datetime.date()：获取date对象； datetime.time()：获取time对象； datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])： datetime.weekday()#不准确，晚一天相对于北京时间 datetime.strftime(format) 像date一样，也可以对两个datetime对象进行比较，或者相减返回一个时间间隔对象，或者日期时间加上一个间隔返回一个新的日期时间对象。 格式字符串 datetime、date、time都提供了strftime()方法，该方法接收一个格式字符串，输出日期时间的字符串表示。 格式字符 意义 %a 星期的简写,如星期三为Web %A 星期的全写,如星期三为Wednesday %b 月份的简写,如4月份为Apr %B 月份的全写,如4月份为April %c 日期时间的字符串表示。（如： 04/07/10 10:43:39） %d 日在这个月中的天数（是这个月的第几天） %f 微秒（范围[0,999999]） %H 小时（24小时制，[0, 23]） %I 小时（12小时制，[0, 11]） %j 日在年中的天数 [001,366]（是当年的第几天） %m 月份（[01,12]） %M 分钟（[00,59]） %p AM或者PM %S 秒（范围为[00,61]） %U 周在当年的周数当年的第几周），星期天作为周的第一天 %w 今天在这周的天数，范围为[0, 6]，6表示星期天 %W 周在当年的周数（是当年的第几周），星期一作为周的第一天 %x 日期字符串（如：04/07/10） %X 时间字符串（如：10:43:39） %y 2个数字表示的年份 %Y 4个数字表示的年份 %z 与utc时间的间隔 （如果是本地时间，返回空字符串） %Z 时区名称（如果是本地时间，返回空字符串） %% %% =&gt; % demo: dt = datetime.now() print ‘(%Y-%m-%d %H:%M:%S %f): ‘, dt.strftime(‘%Y-%m-%d %H:%M:%S %f’) print ‘(%Y-%m-%d %H:%M:%S %p): ‘, dt.strftime(‘%y-%m-%d %I:%M:%S %p’) print ‘%%a: %s ‘ % dt.strftime(‘%a’) print ‘%%A: %s ‘ % dt.strftime(‘%A’) print ‘%%b: %s ‘ % dt.strftime(‘%b’) print ‘%%B: %s ‘ % dt.strftime(‘%B’)","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-函数式编程","slug":"python-函数式编程","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:06:14.237Z","comments":true,"path":"2017/05/04/python-函数式编程/","link":"","permalink":"http://yoursite.com/2017/05/04/python-函数式编程/","excerpt":"高阶函数： 函数本身也可以赋值给变量，即：变量可以指向函数。 a=abs 函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！ 传入函数：","text":"高阶函数： 函数本身也可以赋值给变量，即：变量可以指向函数。 a=abs 函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！ 传入函数：既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 def add(x, y, f): return f(x) + f(y) map/reduce： map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回，举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下： &gt;&gt;&gt; def add(x, y): ... return x + y ... &gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9]) 25 reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： &gt;&gt;&gt; def add(x, y): ... return x + y ... &gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9]) 25 注意：字符串也是序列 filter(): 和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 def is_odd(n): return n % 2 == 1 filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]) 把一个序列中的空字符串删掉，可以这么写： def not_empty(s): return s and s.strip() filter(not_empty, [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, None, &apos;C&apos;, &apos; &apos;]) sorted()排序算法： sorted([36, 5, 12, 9, 21])#对list排序 通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。（倒序排序相反） def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 传入自定义的比较函数reversed_cmp，就可以实现倒序排序： sorted([36, 5, 12, 9, 21], reversed_cmp) 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： 闭包返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 匿名函数 匿名函数lambda x: x * x实际上就是： def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数： f = lambda x: x * x &gt;&gt;&gt; f &lt;function &lt;lambda&gt; at 0x10453d7d0&gt; &gt;&gt;&gt; f(5) 25 装饰器： 1.不带参数的装饰器 函数对象有一个name属性，可以拿到函数的名字： &gt;&gt;&gt; now.__name__ &apos;now&apos; def log(func): def wrapper(*args, **kw): print &apos;call %s():&apos; % func.__name__ return func(*args, **kw) return wrapper log是一个装饰器，接受一个函数，返回一个函数，我们要借助Python的@语法，把decorator置于函数的定义处： @log def now(): print &apos;2013-12-25&apos; 把@log放到now()函数的定义处，相当于执行了语句： now = log(now) 由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。 wrapper()函数的参数定义是(args, *kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。 2.带参数的装饰器 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： def log(text): def decorator(func): def wrapper(*args, **kw): print &apos;%s %s():&apos; % (text, func.__name__) return func(*args, **kw) return wrapper return decorator @log(&apos;execute&apos;) def now(): print &apos;2013-12-25&apos; 类似now = log(‘execute’)(now)首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数 3.一个完整的decorator的写法如下： import functools def log(func): @functools.wraps(func) def wrapper(*args, **kw): print &apos;call %s():&apos; % func.__name__ return func(*args, **kw) return wrapper 或者针对带参数的decorator： import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print &apos;%s %s():&apos; % (text, func.__name__) return func(*args, **kw) return wrapper return decorator 思考： 再思考一下能否写出一个@log的decorator，使它既支持： @log def f(): pass 又支持： @log(&apos;execute&apos;) def f(): pass 代码如下： import functools def log(obj): if isinstance(obj,str): text=obj def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print &apos;begin %s %s():&apos; % (text,func.__name__) func(*args, **kw) print &apos;end %s %s():&apos; % (text,func.__name__) return wrapper return decorator else: func=obj @functools.wraps(func) def wrapper(*args, **kw): print &apos;begin call %s():&apos; % (func.__name__) func(*args, **kw) print &apos;end call %s():&apos; % (func.__name__) return wrapper @log def now(): print &apos;now is \\&apos;2017-01-19\\&apos;&apos; now() @log(&apos;execute&apos;) def now(): print &apos;now is \\&apos;2017-01-19\\&apos;&apos; now() 偏函数： Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function） int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换： 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去： functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： import functools int2 = functools.partial(int, base=2) 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： int2(‘1000000’, base=10)","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-函数","slug":"python-函数","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:05:51.809Z","comments":true,"path":"2017/05/04/python-函数/","link":"","permalink":"http://yoursite.com/2017/05/04/python-函数/","excerpt":"通过help(abs)查看abs函数的帮助信息。 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误","text":"通过help(abs)查看abs函数的帮助信息。 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：a=abs a(-1) 比较函数cmp(x, y)就需要两个参数，如果xy，返回1： all(iter),any(). 定义函数 定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 如果想定义一个什么事也不做的空函数，可以用pass语句： def nop(): pass Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 函数执行完毕也没有return语句时，自动return None。 函数参数 设置默认参数时，有几点要注意： 一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）； 二是如何设置默认参数,当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 可变参数： 可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 加上，传参数时候不用转换为list传进来，而是calc（1,2,3）这样随便传几个函数都可以，然后函数自动把传进来的参数转为一个tuple传进函数，也可以直接calc（x）这样传x进来 关键字参数： 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 def person(name, age, **kw): print &apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw person(1,2,c=5,d=6) name: 1 age: 2 other: {&apos;c&apos;: 5, &apos;d&apos;: 6} 当使用该函数时候，可以只传入必选参数，也可以传入一个dict。 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。 递归函数 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-基础0","slug":"python-基础0","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:09:08.167Z","comments":true,"path":"2017/05/04/python-基础0/","link":"","permalink":"http://yoursite.com/2017/05/04/python-基础0/","excerpt":"关于中文文件txt，先转为utf-8，然后这样存入列表打印不会乱码 import json file=&quot;C://Users/Administrator/Desktop/md.txt&quot; v={} x=1 for line in open(file,&quot;r&quot;): s=line.strip（），#字符串.strip（），去掉\\n换行符和前后空白 v[x]=s x=x+1","text":"关于中文文件txt，先转为utf-8，然后这样存入列表打印不会乱码 import json file=&quot;C://Users/Administrator/Desktop/md.txt&quot; v={} x=1 for line in open(file,&quot;r&quot;): s=line.strip（），#字符串.strip（），去掉\\n换行符和前后空白 v[x]=s x=x+1 print json.dumps(v[2],encoding=&quot;UTF-8&quot;,ensure_ascii=False) #推导式简单 x=[line.strip() for line in open(file)] print json.dumps(x,encoding=&quot;UTF-8&quot;,ensure_ascii=False) 列表里面可以存放字典 x=[{&quot;a&quot;:1245,&quot;b&quot;:55555}] print x[0][&quot;a&quot;] 对时区计数，collections.Counter from collections import Counter y=Counter(x)#对列表计数 y.most_common(n)#输出前n个 #字典迭代与列表排序 y={&quot;a&quot;:3255,&quot;b&quot;:65} x=[(tz,tx) for tx,tz in y.items()] x.sort() print x #pandas 利用pycharm安装，file-settings-project-project interpreter-“+”-pandas/numpy from pandas import DataFrame,Series import pandas,numpy y={&quot;a&quot;:3255,&quot;b&quot;:65} x=[(tz,tx) for tx,tz in y.items()] x=DataFrame(x)#将列表生成数据表 print x[1][1:]#打印x的第一列的角标从1开始的数据 x[1].value_counts()#返回计数 x[0][x[0]==&quot;&quot;]=&quot;un&quot;#将x第0列的满足条件的数据设置为“un“ 作图在pycharm并显示 import matplotlib.pyplot as plt z=x[0] z.plot(kind=&quot;barh&quot;,title=&quot;hhhh&quot;) plt.show() sum(x,-1) 类似求和后减去","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-字典","slug":"python-字典","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:05:13.914Z","comments":true,"path":"2017/05/04/python-字典/","link":"","permalink":"http://yoursite.com/2017/05/04/python-字典/","excerpt":"可存储任意类型对象，可变。字典包含在花括号里面，键值对用冒号分割，对之间用逗号分割，键key必须是唯一的，不可变的，如字符串，数字，元组。 索引，修改 dict［“a”］ 删除字典元素del dict［“a”］ 删除字典 del dict 清空字典dict.clear（） 字典值可以无限制的取任何Python对象","text":"可存储任意类型对象，可变。字典包含在花括号里面，键值对用冒号分割，对之间用逗号分割，键key必须是唯一的，不可变的，如字符串，数字，元组。 索引，修改 dict［“a”］ 删除字典元素del dict［“a”］ 删除字典 del dict 清空字典dict.clear（） 字典值可以无限制的取任何Python对象 不许同一个键出现两次，键必须为不可变对象。 字典内置函数方法 len（）计算字典元素数 str（dict）输出字典以字符串形式 type（var）返回输入的变量类型 dict.clear（）清空字典 dict.copy（）返回字典浅复制 dict.values（）以列表返回字典所有值 dict.key（）类似上 dict.update（dict2）把dict2键值对更新进dict中 dict.get（key，default=）返回指定key的值，如果没有返回default的值 dict.setdefault（key，default=）与get类似，只是若key不存在，则加进去键值对 key in dict 返回布尔值 dict.items（）以列表返回可遍历的键值元组数组 d.itervalues()返回value的迭代器 d.iteritems()返回key的迭代器","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-列表","slug":"python-列表","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:02:50.156Z","comments":true,"path":"2017/05/04/python-列表/","link":"","permalink":"http://yoursite.com/2017/05/04/python-列表/","excerpt":"列表操作包含索引，切片，加，乘，检查成员。 列表数据项可以为不同的类型。 列表可变，［］索引，［：］切片。 删除列表中元素del list［2］。 列表脚本操作符 len（）长度，+组合，*重复，in是否存在，","text":"列表操作包含索引，切片，加，乘，检查成员。 列表数据项可以为不同的类型。 列表可变，［］索引，［：］切片。 删除列表中元素del list［2］。 列表脚本操作符 len（）长度，+组合，*重复，in是否存在， for x in list： print x迭代 列表可以嵌套列表或其他类型 列表函数方法 len（）列表元素数 max（）返回列表元素最大值 min（）返回元素最小值 list（seq）元组转列表 list.append（）添加新元素 list.count（obj）对list中obj计数 list.extend（seq）在list后添加seq值 list.index（obj）返回第一个匹配的obj的索引 list.insert（index，obj）指定位置插入对象 list.pop(obj=list［-1］)移除最后一个obj list.pop()删除最后一个元素 list.popleft（），删除第一个元素 list.remove（obj）移除第一个匹配的obj list.reverse（）反向列表中元素 list.sort（［func］）指定函数排序 list.clear（）清空列表 list.copy（）复制列表 列表具有堆栈的特性，先进后出。 也具有队列的特性，先进先出","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-基础数据结构","slug":"python-基础数据结构","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:01:59.480Z","comments":true,"path":"2017/05/04/python-基础数据结构/","link":"","permalink":"http://yoursite.com/2017/05/04/python-基础数据结构/","excerpt":"Python的变量不需要声明，但必须被赋值该变量才存在。多个变量赋值被分配同一个内存。 六种数据类型 number（数字），int float bool complex， string（字符串），+连接，*复制字符串，不可以被改变 list（列表），+，*，可以被改变 tuple（元组），+，不可变的列表 set（集合），无序不重复序列，空集合用set（）不用｛｝ dict（字典），空字典｛｝，是一种映射类型","text":"Python的变量不需要声明，但必须被赋值该变量才存在。多个变量赋值被分配同一个内存。 六种数据类型 number（数字），int float bool complex， string（字符串），+连接，*复制字符串，不可以被改变 list（列表），+，*，可以被改变 tuple（元组），+，不可变的列表 set（集合），无序不重复序列，空集合用set（）不用｛｝ dict（字典），空字典｛｝，是一种映射类型 Python数据类型转换 int（），float（），str（），tuple（），list（），set（），dict（），chr（） unichr（）将整数转为unicode字符 ord（）将一个字符转为他的整数值 oct（）转八进制 hex（）转十六进制 repr（）转为表达式字符串 运算符 算术运算符 +，-，，╱，*幂，％求模，╱╱取整 比较运算符（返回布尔值） ==，!=，&lt;，&gt;，&gt;=，&lt;= 赋值运算符 =，+= a+=b a=a+b，-=，*=，╱=，％=， **=，％= 逻辑运算符 and，or，&amp;，| 成员运算符 in，not in 身份运算符 is，is not，看两个变量是否引用同一个对象","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-格式化处理","slug":"python-格式化处理","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:01:42.650Z","comments":true,"path":"2017/05/04/python-格式化处理/","link":"","permalink":"http://yoursite.com/2017/05/04/python-格式化处理/","excerpt":"％d，有符号的十进制整数 ％u，无符号十进制整数 ％o，无符号8进制整数 ％a，浮点数，16进制数字","text":"％d，有符号的十进制整数 ％u，无符号十进制整数 ％o，无符号8进制整数 ％a，浮点数，16进制数字 ％e，浮点数，e记数法 ％f，浮点数，10进制数字 ％g，自动选择％f或％e ％c，一个字符 ％s，字符串 ％％，打印一个百分号 用法如下 x=5 print “gsjsjjdj ％d” ％（x） 四个二进制位是一个16进制位 三个二进制位是一个8进制位","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-字符串","slug":"python-字符串","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:08:14.785Z","comments":true,"path":"2017/05/04/python-字符串/","link":"","permalink":"http://yoursite.com/2017/05/04/python-字符串/","excerpt":"可以使用［］来截取字符串，字符串可变。 字符串运算符 +，*，［］，［:］，in，not in，r“”。 字符串格式化见另一篇笔记 Python3中，所有字符串都是unicode字符串 Python字符串内置函数 capitalize（）将字符串首字母转大写 count（str，beg，end）计算str次数 decode（encoding，errors=“strict”）解码 encode（）编码 endswith（str，beg，end）查找是否是str结尾，返回布尔值。 startswith（）。","text":"可以使用［］来截取字符串，字符串可变。 字符串运算符 +，*，［］，［:］，in，not in，r“”。 字符串格式化见另一篇笔记 Python3中，所有字符串都是unicode字符串 Python字符串内置函数 capitalize（）将字符串首字母转大写 count（str，beg，end）计算str次数 decode（encoding，errors=“strict”）解码 encode（）编码 endswith（str，beg，end）查找是否是str结尾，返回布尔值。 startswith（）。 rfind（）从右边开始查找。 find（str，beg，end）返回索引，无返回-1。 index（str，beg，end）上一样，无报异常。 rindex（）。 isalnum（）判断全是数字或字母，isalpha（）全是字母，isdigit（）全为数字。 #str.isalnum() len（）返回长度，join（seq）将序列的元素合为一个字符串，lower（）转小写，upper（），lstrip（）截掉左边空格，rstrip（）。 str.replace（old，new）替换 str.split（str=“”，num=）截字符串num表示切割几次 splitlines（num）按照行截取字符串 strip（）去掉首尾空格 swapcase（）同时转换大小写 zfill（n）返回长度n的0填充字符串 #&quot;dd&quot;.zfill(10)","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-异常处理","slug":"python-异常处理","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:08:38.699Z","comments":true,"path":"2017/05/04/python-异常处理/","link":"","permalink":"http://yoursite.com/2017/05/04/python-异常处理/","excerpt":"1.语法错误SyntaxError，少些函数字母等错误 2.异常， try： 语句 except error： 语句 else ： try语句没有异常发生会执行else，有异常发生不执行 当有多个except时候 最后一个except后可以没有异常名称","text":"1.语法错误SyntaxError，少些函数字母等错误 2.异常， try： 语句 except error： 语句 else ： try语句没有异常发生会执行else，有异常发生不执行 当有多个except时候 最后一个except后可以没有异常名称当调用的函数抛出异常时候，try语句执行发现异常也会except 异常自动清理 finally： 一定执行的语句 demo： try: print ‘try…’ r = 10 / int(‘a’) print ‘result:’, r except ValueError, e: print ‘ValueError:’, e except ZeroDivisionError, e: print ‘ZeroDivisionError:’, e else: print ‘no error!’ finally: print ‘finally…’ print ‘END’ 3.Python的错误其实也是class，所有的错误类型都继承自BaseException 4.Python内置的logging模块可以非常容易地记录错误信息： import logging try: bar(&apos;0&apos;) except StandardError, e: logging.exception(e) 同样是出错，但程序打印完错误信息后会继续执行，并正常退出 5.接收一个错误但是不做处理，抛给顶层调用者 try: return foo(s) * 2 except StandardError, e: print &apos;Error!&apos; raise 6.所有的错误继承关系 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StandardError | +-- BufferError | +-- ArithmeticError | | +-- FloatingPointError | | +-- OverflowError | | +-- ZeroDivisionError | +-- AssertionError | +-- AttributeError | +-- EnvironmentError | | +-- IOError | | +-- OSError | | +-- WindowsError (Windows) | | +-- VMSError (VMS) | +-- EOFError | +-- ImportError | +-- LookupError | | +-- IndexError | | +-- KeyError | +-- MemoryError | +-- NameError | | +-- UnboundLocalError | +-- ReferenceError | +-- RuntimeError | | +-- NotImplementedError | +-- SyntaxError | | +-- IndentationError | | +-- TabError | +-- SystemError | +-- TypeError | +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"python-输入和输出","slug":"python-输入和输出","date":"2017-05-03T16:00:00.000Z","updated":"2017-09-29T01:04:12.293Z","comments":true,"path":"2017/05/04/python-输入和输出/","link":"","permalink":"http://yoursite.com/2017/05/04/python-输入和输出/","excerpt":"print（），打印函数，str（）返回字符串，repr（）返回一个解释器易读的表达形式。 repr（）可以接受Python的任何对象 repr（10）.rjust（6），返回的结果前面加6个空格 format（）的使用","text":"print（），打印函数，str（）返回字符串，repr（）返回一个解释器易读的表达形式。 repr（）可以接受Python的任何对象 repr（10）.rjust（6），返回的结果前面加6个空格 format（）的使用 print ‘{}:”{}”‘.format(“ssss”,”dfsdfsdf”) 结果：ssss:”dfsdfsdf” print “{1},{0}”.format(“gdf”,”FGH”) 读写见利用py进行数据分析最后 input（）读取用户键盘输入 文本操作 file.close()关闭文件 file.flush()刷新缓冲区 file.next()返回文件下一行 file.read([size])读取固定的字节，如果没有设置则全读 file.readline()读取整行 file.readlines（）读取所有行并返回列表 file.tell()返回文件的当前位置 file.seek()设置文件当前位置 file.truncake(size)截取固定的字节 file.write(str)将字符串写入文件 file.writelines（seq）将序列写入文件，如果要换行自己加换行符","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python基础/"}],"tags":[]},{"title":"shiny部署到shinyapps.io","slug":"shiny部署到shinyapps-io","date":"2017-04-30T02:28:33.000Z","updated":"2017-04-28T09:04:47.710Z","comments":true,"path":"2017/04/30/shiny部署到shinyapps-io/","link":"","permalink":"http://yoursite.com/2017/04/30/shiny部署到shinyapps-io/","excerpt":"一切操作基于Rstudio shinyapps网站shinyapps.io","text":"一切操作基于Rstudio shinyapps网站shinyapps.io 注册shinyapps.io网站会员 install.packages(&apos;rsconnect&apos;) library(rsconnect) 令牌页面上点击显示按钮。会弹出一个窗口,显示了完整的命令来配置您的帐户使用适当的参数rsconnect::setAccountInfo函数。这个命令复制到你的剪贴板,然后将它粘贴到命令行RStudio并单击enter。 本地测试app是否正常 library(shiny) runApp() 部署到shinyapps library(rsconnect) deployApp()","categories":[{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/categories/shiny/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"},{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/tags/shiny/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"ui端小部件","slug":"ui端小部件","date":"2017-04-30T02:25:21.000Z","updated":"2017-04-28T09:04:58.475Z","comments":true,"path":"2017/04/30/ui端小部件/","link":"","permalink":"http://yoursite.com/2017/04/30/ui端小部件/","excerpt":"actionButton：事件动作按钮 checkboxGroupInput：复选框组，多选框，打钩的 checkboxInput：单个复选框，单个打钩的","text":"actionButton：事件动作按钮 checkboxGroupInput：复选框组，多选框，打钩的 checkboxInput：单个复选框，单个打钩的 dateInput：日期选择控件 dateRangeInput：日期区间选择控件 fileInput：文件上传控件 helpText：帮助文档，类似word里面的文本框 numericInput：数值输入框 radioButtons：单选按钮，多个选项但只能选一个，打点的 selectInput：下拉选框，待选盒 sliderInput：滑动条 submitButton：提交按钮 textInput：文本输入框","categories":[{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/categories/shiny/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"},{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/tags/shiny/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"动漫区爬虫源码2-来自58壁纸","slug":"动漫区爬虫源码2-来自58壁纸","date":"2017-04-30T02:01:25.000Z","updated":"2017-04-28T09:05:10.465Z","comments":true,"path":"2017/04/30/动漫区爬虫源码2-来自58壁纸/","link":"","permalink":"http://yoursite.com/2017/04/30/动漫区爬虫源码2-来自58壁纸/","excerpt":"采用动漫爬虫包rvest，创新点，写进文件以utf-8，写入特定的文件头内容，能够直接上传hexo，读取gb2312编码的网站 源码：","text":"采用动漫爬虫包rvest，创新点，写进文件以utf-8，写入特定的文件头内容，能够直接上传hexo，读取gb2312编码的网站 源码： library(rvest) zz&lt;-list() for(i in 1:25){ url&lt;-paste(&quot;http://www.bz55.com/dongmanbizhi/ list_3_&quot;,i,&quot;.html&quot;,sep=&quot;&quot;) web&lt;-read_html(url,encoding=&quot;GBK&quot;) zz[[i]]&lt;-web%&gt;%html_nodes(&quot;div.list_txt&quot;)%&gt;% html_nodes(&quot;ul&quot;)%&gt;%html_nodes(&quot;li&quot;)%&gt;%html_nodes(&quot;a&quot;) %&gt;%html_attr(&quot;href&quot;) zz[[i]]&lt;-zz[[i]][1:12] } zz&lt;-unlist(zz) for(i in 1:length(zz)){ z&lt;-list() url&lt;-paste(&quot;http://www.bz55.com&quot;,zz[i],sep=&quot;&quot;) web&lt;-read_html(url,encoding = &quot;GBK&quot;) text&lt;-web%&gt;%html_nodes(&quot;p&quot;)%&gt;%html_nodes(&quot;img&quot;)%&gt;% html_attr(&quot;alt&quot;) text&lt;-text[1] text&lt;-gsub(&quot; &quot;,&quot;&quot;,text) tt&lt;-paste(&quot;---\\n&quot;,&quot;title: &quot;,text,&quot;\\n&quot;,&quot;date: 2017-04-29\\n&quot;,&quot;categories: 动漫\\n&quot;,&quot;---\\n&quot;,sep=&quot;&quot;) tt&lt;-enc2utf8(tt) f&lt;-file(paste(&quot;H:/ dfgh/&quot;,text,&quot;.md&quot;,sep=&quot;&quot;),&quot;a&quot;,encoding = &quot;UTF-8&quot;) cat(tt, file=f) tryCatch({ url&lt;-paste(&quot;http://www.bz55.com&quot;,zz[i],sep=&quot;&quot;) web&lt;-read_html(url,encoding = &quot;GBK&quot;) z[[i]]&lt;-web%&gt;%html_nodes(&quot;p&quot;)%&gt;%html_nodes(&quot;img&quot;)%&gt;% html_attr(&quot;src&quot;) },error=function(e){ cat(&quot;error:&quot;,conditionMessage(e),&quot;\\n&quot;) }) z&lt;-unlist(z) z&lt;-paste(&quot;![alt](&quot;,&quot;http://www.bz55.com&quot;,z,&quot;)&quot;,sep=&quot;&quot;) write.table(z,f,row.names = F,col.names = F,quote = F) close(f) }","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[]},{"title":"动漫区爬虫源码1-来自动漫星空","slug":"动漫区爬虫源码1-来自动漫星空","date":"2017-04-30T02:01:07.000Z","updated":"2017-04-28T09:05:20.654Z","comments":true,"path":"2017/04/30/动漫区爬虫源码1-来自动漫星空/","link":"","permalink":"http://yoursite.com/2017/04/30/动漫区爬虫源码1-来自动漫星空/","excerpt":"采用动漫爬虫包rvest，创新点，写进文件以utf-8，写入特定的文件头内容，能够直接上传hexo 源码：","text":"采用动漫爬虫包rvest，创新点，写进文件以utf-8，写入特定的文件头内容，能够直接上传hexo 源码： url&lt;-&quot;http://acg.gamersky.com/pic/wallpaper/pc/&quot; web&lt;-read_html(url,encoding=&quot;UTF-8&quot;) t&lt;-web%&gt;%html_nodes(&quot;li.img&quot;)%&gt;%html_nodes(&quot;a&quot;)%&gt;% html_attr(&quot;href&quot;) for(j in 1:length(t)){ web22&lt;-read_html(t[j],encoding = &quot;UTF-8&quot;) text&lt;-web22%&gt;%html_node(&quot;title&quot;)%&gt;%html_text() text&lt;-gsub(&quot; &quot;,&quot;&quot;,text) tt&lt;-paste(&quot;---\\n&quot;,&quot;title: &quot;,text,&quot;\\n&quot;,&quot;date: 2017-04-28\\n&quot;,&quot;categories: 动漫\\n&quot;,&quot;---\\n&quot;,sep=&quot;&quot;) tt&lt;-enc2utf8(tt) f&lt;-file(paste(&quot;H:/ dfgh/&quot;,text,&quot;.md&quot;,sep=&quot;&quot;),&quot;a&quot;,encoding = &quot;UTF-8&quot;) cat(tt, file=f) ##写进头文件，编码utf-8 z&lt;-list() tryCatch({ for(i in 1:6){ if(i==1){ web2&lt;-read_html(t[j],encoding = &quot;UTF-8&quot;) z[[i]]&lt;-web2%&gt;%html_nodes(&quot;img.picact&quot;)%&gt;%html_attr(&quot;src&quot;) }else{ url2&lt;-gsub(&quot;.shtml&quot;,&quot;&quot;,t[j]) web2&lt;-read_html(paste (url2,&quot;_&quot;,i,&quot;.shtml&quot;,sep=&quot;&quot;),encoding = &quot;UTF-8&quot;) z[[i]]&lt;-web2%&gt;%html_nodes(&quot;img.picact&quot;)%&gt;%html_attr(&quot;src&quot;) }} },error=function(e){ cat(&quot;error:&quot;,conditionMessage(e),&quot;\\n&quot;) }) z&lt;-unlist(z) z&lt;-paste(&quot;![alt](&quot;,z,&quot;)&quot;,sep=&quot;&quot;) write.table(z,f,row.names = F,col.names = F,quote = F) close(f) }","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[]},{"title":"shiny参考-滑动条","slug":"shiny参考-滑动条","date":"2017-04-28T02:34:45.000Z","updated":"2017-04-28T02:54:32.882Z","comments":true,"path":"2017/04/28/shiny参考-滑动条/","link":"","permalink":"http://yoursite.com/2017/04/28/shiny参考-滑动条/","excerpt":"shiny案列库 案列库，可以参考官方源码 主要是滑动条函数，可复制代码进rstudio本地运行，因为shinyapps.io免费版只能部署5个，所以这些没有部署到我的shinyapps上。 新建shiny项目，rstudio–file–new project–new directory–shiny web","text":"shiny案列库 案列库，可以参考官方源码 主要是滑动条函数，可复制代码进rstudio本地运行，因为shinyapps.io免费版只能部署5个，所以这些没有部署到我的shinyapps上。 新建shiny项目，rstudio–file–new project–new directory–shiny web 滑动条： library(shiny) shinyUI(pageWithSidebar( headerPanel(&quot;Sliders&quot;), sidebarPanel( sliderInput(&quot;integer&quot;, &quot;Integer:&quot;, min=0, max=1000, value=500), sliderInput(&quot;decimal&quot;, &quot;Decimal:&quot;, min = 0, max = 1, value = 0.5, step= 0.1), sliderInput(&quot;range&quot;, &quot;Range:&quot;, min = 1, max = 1000, value = c(200,500)), sliderInput(&quot;format&quot;, &quot;Custom Format:&quot;, min = 0, max = 10000, value = 0, step = 2500, locale=&quot;us&quot;, animate=TRUE), sliderInput(&quot;animation&quot;, &quot;Looping Animation:&quot;, 1, 2000, 1, step = 10, animate=animationOptions(interval=300, loop=T)) ), mainPanel( tableOutput(&quot;values&quot;) ) )) 服务端： library(shiny) shinyServer(function(input, output) { sliderValues &lt;- reactive({ # Compose data frame data.frame( Name = c(&quot;Integer&quot;, &quot;Decimal&quot;, &quot;Range&quot;, &quot;Custom Format&quot;, &quot;Animation&quot;), Value = as.character(c(input$integer, input$decimal, paste(input$range, collapse=&apos; &apos;), input$format, input$animation)), stringsAsFactors=FALSE) }) output$values &lt;- renderTable({ sliderValues() }) })","categories":[{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/categories/shiny/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"},{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/tags/shiny/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"多功能shiny网站搭建源码","slug":"多功能shiny网站搭建源码","date":"2017-04-21T04:00:34.000Z","updated":"2017-06-03T07:50:47.555Z","comments":true,"path":"2017/04/21/多功能shiny网站搭建源码/","link":"","permalink":"http://yoursite.com/2017/04/21/多功能shiny网站搭建源码/","excerpt":"目前实现的功能有，查看图片URL，文字，在线简体转繁体，词云，河南天气查询，在线爬虫爬取图片文字，在线实时观看漫画。 网址shiny","text":"目前实现的功能有，查看图片URL，文字，在线简体转繁体，词云，河南天气查询，在线爬虫爬取图片文字，在线实时观看漫画。 网址shiny 源代码如下： UI端： library(shiny) library(shinythemes) library(wordcloud2) library(ropencc) library(rvest) shinyUI(tagList( navbarPage( &quot;&quot;, theme = shinythemes::shinytheme(&quot;slate&quot;), tabPanel(&quot;百思不得姐&quot;, sidebarPanel( fileInput(&apos;file1&apos;, &apos;图片url文件&apos;), helpText(&quot;要求的文件格式，txt文件，\\n回车键作为分割，里面保存的是图片的url&quot;), radioButtons(&quot;dist&quot;, &quot;按照你的需求选择:&quot;, list(&quot;我自己上传文件&quot; =&quot;a&quot;, &quot;使用内置图片文件1&quot;=&quot;b&quot;, &quot;使用内置图片文件2&quot;=&quot;c&quot; )), actionButton(&quot;updata&quot;, &quot;下一张&quot;), tags$br(), tags$br(), ###table1 helpText(&quot;选择合适的选项，然后点击下一张&quot;), fileInput(&apos;file&apos;, &apos;文字文件&apos;), helpText(&quot;要求的文件格式，txt文件，\\n回车键作为分割，里面保存的是文字&quot;), radioButtons(&quot;dist1&quot;, &quot;按照你的需求选择:&quot;, list(&quot;我自己上传文件&quot; =TRUE, &quot;使用内置文字文件&quot;=FALSE )), numericInput(&quot;num&quot;, &quot;选择显示个数:&quot;,5), actionButton(&quot;next1&quot;, &quot;下一条&quot;), helpText(&quot;选择合适的选项，然后点击下一条&quot;) ###table2 ), ####uioutput mainPanel( tabsetPanel( tabPanel(&quot;图片&quot;, h4(&quot;案列图片来自爬虫爬取&quot;), uiOutput(&quot;moreControls&quot;) ), tabPanel(&quot;文字&quot;, h4(&quot;案列文字来自爬虫爬取&quot;), tableOutput( &quot;text&quot; ) ) ) ) ), tabPanel(&quot;简体转繁体&quot;, sidebarPanel( fileInput(&apos;file2&apos;, &apos;请上传txt文件&apos;), actionButton(&quot;gofan&quot;, &quot;输出繁体&quot;), tags$br(), tags$br(), textInput(&quot;wenben&quot;,&quot;请输入简体文字：&quot;,&quot;你好,世界&quot;), actionButton(&quot;view&quot;, &quot;输出繁体&quot;) ), mainPanel( tabsetPanel( tabPanel(&quot;上传文件转换&quot;, h4(&quot;结果展示&quot;), tableOutput(&quot;text1&quot;) ), tabPanel(&quot;输入文本转换&quot;, h4(&quot;结果展示&quot;), textOutput(&quot;text2&quot;) ) )) ), tabPanel(&quot;词云-love&quot;, sidebarPanel( textInput(&quot;name&quot;,&quot;请输入名字:&quot;,&quot;you name&quot;), actionButton(&quot;ciyun&quot;, &quot;生成词云图&quot;), helpText(&quot;你好，输入姓名点击按钮自动生成词云图，该功能暂时不完善&quot;) ), mainPanel( tabsetPanel( tabPanel(&quot;词云-love&quot;, h4(&quot;词云-love&quot;), wordcloud2Output(&quot;image&quot;, width = &quot;100%&quot;, height = &quot;400px&quot;) ), tabPanel(&quot;词云-用户输入&quot;, h4(&quot;词云-用户输入&quot;), textOutput(&quot;yyy&quot;) ) ) ) ), tabPanel(&quot;在线爬虫&quot;, sidebarPanel( numericInput(&quot;num2&quot;, label = &quot;1~50之间&quot;, value = 1), numericInput(&quot;num1&quot;, label = &quot;1~20之间&quot;, value = 1), actionButton(&quot;zaixian&quot;, &quot;更新页面&quot;), helpText(&quot;你好，请选择1~50代表页码，1~20代表第几页的第几个内容，请不要超过这两个数字大小&quot;), tags$br(), helpText(&quot;服务器由shinyapps.io免费提供，所以速度较慢&quot;) ), mainPanel( tabsetPanel( tabPanel(&quot;在线爬虫&quot;, h4(&quot;内容来自百思不得姐图片区&quot;), tableOutput(&quot;re1&quot;), uiOutput(&quot;re2&quot;) ) ) ) ), tabPanel(&quot;河南天气系统&quot;, sidebarPanel( textInput(&quot;sql&quot;,&quot;市级:&quot;,&quot;郑州&quot;), textInput(&quot;sql1&quot;,&quot;县级:&quot;,&quot;郑州&quot;), actionButton(&quot;tianqi&quot;, &quot;更新页面&quot;), helpText(&quot;请分别输入市县，如洛阳-伊川，信息实时来自于中国天气网&quot;), tags$br(), helpText(&quot;服务器由shinyapps.io免费提供，所以速度较慢&quot;) ), mainPanel( tabsetPanel( tabPanel(&quot;天气查询&quot;, h4(&quot;信息来自中国天气网&quot;), tableOutput(&quot;tianqi&quot;) ) ) ) ), tabPanel(&quot;恐怖漫画&quot;, sidebarPanel( numericInput(&quot;kbnum&quot;, label = &quot;1~25之间&quot;, value = 1), numericInput(&quot;kbnum1&quot;, label = &quot;按照需求选择&quot;, value = 1), actionButton(&quot;kb2&quot;, &quot;更新页面&quot;), helpText(&quot;服务器由shinyapps.io免费提供，所以速度较慢&quot;) ), mainPanel( uiOutput(&quot;kbui&quot;) ) ) ) ) ) 服务端： library(shiny) library(shinythemes) library(wordcloud2) library(ropencc) library(rvest) shinyServer(function(input, output) { sliderValues &lt;- reactive({ aa&lt;-switch(input$dist, a=1, b=2, c=3, 1) }) sliderValues1 &lt;- reactive({ aa&lt;-sliderValues() if(aa==1){ inFile &lt;- input$file1 if (is.null(inFile)) return(NULL) zzz&lt;-scan(inFile$datapath,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) }else if(aa==2){ zzz&lt;-scan(&quot;./zzz.txt&quot;,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) }else{ zzz&lt;-scan(&quot;./mei.txt&quot;,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) } }) df &lt;- eventReactive(input$updata, { aa&lt;-sliderValues() zzz&lt;-sliderValues1() if(aa==1){ x&lt;-sample(1:length(zzz),1,replace = FALSE) }else if(aa==2){ x&lt;-sample(1:1000,1,replace = FALSE) }else{ x&lt;-sample(1:339,1,replace = FALSE) } }) output$moreControls &lt;- renderUI({ df&lt;-df() zzz&lt;-sliderValues1() pre&lt;-zzz[[df]] tags$img(src=pre) }) ###table1 xh&lt;-reactive({ if(input$dist1){ inFile &lt;- input$file1 if (is.null(inFile)) return(NULL) xh&lt;-scan(inFile$datapath,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) }else{ xh&lt;-scan(&quot;./xiaohua.txt&quot;,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) } }) df1&lt;- eventReactive(input$next1, { x&lt;-sample(1:997,1,replace = FALSE) }) output$text&lt;-renderTable({ xh&lt;-xh() df1&lt;-df1() y&lt;-input$num xh[df1:(df1+y-1)] }) ###table2 ###navbar1 na21&lt;- eventReactive(input$gofan,{ inFile &lt;- input$file2 if (is.null(inFile)) return(NULL) fan&lt;-scan(inFile$datapath,sep=&quot;\\n&quot;,what = &quot;&quot;,encoding = &quot;UTF-8&quot;) }) na22&lt;- eventReactive(input$view, { na22&lt;-input$wenben }) output$text1&lt;-renderTable({ fan&lt;-na21() converter(S2T)[fan] }) ##table1 output$text2&lt;-renderText({ na22&lt;-na22() converter(S2T)[na22] }) ##na2 ciyun&lt;-eventReactive(input$ciyun, { name&lt;-input$name cipin&lt;-c(rep(&quot;happy&quot;,10),rep(&quot;miss&quot;,12),rep(&quot;love&quot;,14),rep(&quot;you&quot;,10),rep(&quot;like&quot;,12), rep(&quot;sweet&quot;,10),rep(&quot;hourse&quot;,12),rep(&quot;surprise&quot;,13),rep(&quot;dream&quot;,12),rep(&quot;free&quot;,12), rep(&quot;with you&quot;,14),rep(&quot;life&quot;,13),rep(&quot; together&quot;,13),rep(&quot;eternity&quot;,12),rep(&quot;destiny&quot;,6),rep(&quot;cherish&quot;,5), rep(&quot;sunflower&quot;,10),rep(&quot;galaxy&quot;,5),rep(&quot;moment&quot;,14),rep(&quot;bubble&quot;,3),rep(&quot;smile&quot;,7),rep(&quot;lollipop&quot;,8),rep(&quot;umbrella&quot;,8)) cipin1&lt;-c(cipin,rep(name,15)) citab&lt;-table(cipin1) }) output$yyy&lt;-renderText({ input$name }) output$image&lt;-renderWordcloud2({ citab&lt;-ciyun() wordcloud2(citab,size = 0.5,color = &apos;random-dark&apos;,backgroundColor = &quot;snow&quot;,shape=&quot;diamond&quot;) }) ##na3 zaixian&lt;- eventReactive(input$zaixian, { url&lt;-paste(&quot;http://www.budejie.com/pic/&quot;,input$num2,sep=&quot;&quot;) web&lt;-read_html(url,encoding = &quot;UTF-8&quot;) x&lt;-web%&gt;%html_nodes(&quot;div.j-r-list-tool-ct-fx&quot;)%&gt;%html_nodes(&quot;div&quot;)%&gt;%html_attr(&quot;data-text&quot;) y&lt;-web%&gt;%html_nodes(&quot;div.j-r-list-c-img&quot;)%&gt;%html_nodes(&quot;img&quot;)%&gt;%html_attr(&quot;data-original&quot;) re&lt;-list() for(i in 1:20){ re[[x[i]]]&lt;-y[i] } re }) output$re1 &lt;- renderTable({ re&lt;-zaixian() names(re[input$num1]) }) output$re2 &lt;- renderUI({ re&lt;-zaixian() ree&lt;-re[[input$num1]] tags$img(src=ree) }) ###na4 tianqieve&lt;-eventReactive(input$tianqi,{ web11&lt;-read_html(&quot;http://www.weather.com.cn/textFC/henan.shtml&quot;,encoding=&quot;UTF-8&quot;) web12&lt;-web11%&gt;%html_nodes(&quot;div.conMidtab3&quot;) y&lt;-web12%&gt;%html_nodes(&quot;td.rowsPan&quot;)%&gt;%html_text() y&lt;-y[1:18] i&lt;-which(y==input$sql) i&lt;-as.numeric(i) x&lt;-web12[[i]]%&gt;%html_text() x&lt;-strsplit(x,split = &quot;详情&quot;) x&lt;-unlist(x) x&lt;-gsub(&quot;\\n{1,2}&quot;,&quot; &quot;,x) x&lt;-strsplit(x,split = &quot; &quot;) x&lt;-do.call(cbind,x) x&lt;-as.data.frame(x,stringsAsFactors=F) x&lt;-x[-1,] x&lt;-x[,-dim(x)[2]] colnames(x)&lt;-x[1,] x[[1]]&lt;-c(x[[1]][-1],NA) x&lt;-x[-dim(x)[1],] rownames(x)&lt;-c(&quot;城市&quot;,&quot;天气现象-白天&quot;,&quot;风向-白天&quot;,&quot;风力-白天&quot;,&quot;气温-白天&quot;,&quot;天气现象-夜间&quot;,&quot;风向-夜间&quot;,&quot;风力-夜间&quot;,&quot;气温-夜间&quot;) z&lt;-x[,input$sql1,drop=F] }) output$tianqi&lt;-renderTable({ z&lt;-tianqieve() t(z) }) ###na5 kb1&lt;-reactive({ urlkb&lt;-paste(&quot;http://heibaimanhua.com/weimanhua/kbmh/page/&quot;,input$kbnum,sep=&quot;&quot;) webkb&lt;-read_html(urlkb,encoding = &quot;UTF-8&quot;) kbx&lt;-webkb%&gt;%html_nodes(&quot;article.excerpt.excerpt-one&quot;)%&gt;%html_nodes(&quot;a&quot;)%&gt;%html_attr(&quot;title&quot;) kby&lt;-webkb%&gt;%html_nodes(&quot;article.excerpt.excerpt-one&quot;)%&gt;%html_nodes(&quot;a&quot;)%&gt;%html_attr(&quot;href&quot;) kbkb&lt;-list() for(i in 1:length(kbx)){ kbkb[[kbx[i]]]&lt;-kby[i] } kbkb }) output$kbkbtext&lt;-renderTable({ kb1&lt;-kb1() paste(1:length(names(kb1)),names(kb1),sep=&quot;,&quot;) }) kb2&lt;-eventReactive(input$kb2,{ kb1&lt;-kb1() kbnum1&lt;-input$kbnum1 urlkb1&lt;-kb1[[kbnum1]] webkb1&lt;-read_html(urlkb1,encoding = &quot;UTF-8&quot;) kbjie&lt;-webkb1%&gt;%html_nodes(&quot;article.article-content&quot;)%&gt;%html_nodes(&quot;img&quot;)%&gt;%html_attr(&quot;src&quot;) }) output$kbui&lt;-renderUI({ kb2&lt;-kb2() tabsetPanel( tabPanel(&quot;目录&quot;, tableOutput(&quot;kbkbtext&quot;) ), tabPanel(&quot;在线漫画&quot;, tags$img(src=kb2[1]), tags$img(src=kb2[2]), tags$img(src=kb2[3]), tags$img(src=kb2[4]), tags$img(src=kb2[5]), tags$img(src=kb2[6]), tags$img(src=kb2[7]), tags$img(src=kb2[8]), tags$img(src=kb2[9]), tags$img(src=kb2[10]), tags$img(src=kb2[11]), tags$img(src=kb2[12]), tags$img(src=kb2[13]), tags$img(src=kb2[14]), tags$img(src=kb2[15]), tags$img(src=kb2[16]), tags$img(src=kb2[17]) )) }) })","categories":[{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/categories/shiny/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"},{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/tags/shiny/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"豆瓣相册爬虫","slug":"豆瓣相册爬虫","date":"2017-04-17T09:30:55.000Z","updated":"2017-04-26T10:43:44.288Z","comments":true,"path":"2017/04/17/豆瓣相册爬虫/","link":"","permalink":"http://yoursite.com/2017/04/17/豆瓣相册爬虫/","excerpt":"本次爬取的为豆瓣博主笨笨的小熊的相册，全是温馨的情侣照工具：R，RCurl，xml","text":"本次爬取的为豆瓣博主笨笨的小熊的相册，全是温馨的情侣照工具：R，RCurl，xml install.packages(&quot;RCurl&quot;) install.packages(&quot;XML&quot;) library(RCurl) library(XML) myHttpheader &lt;- c(&quot;User-Agent&quot;=&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1.6) &quot;, &quot;Accept&quot;=&quot;text/html,application/xhtml+xml,application/ xml;q=0.9,*/*;q=0.8&quot;,&quot;Accept-Language&quot;=&quot;en-us&quot;, &quot;Connection&quot;=&quot;keep-alive&quot;, &quot;Accept-Charset&quot;=&quot;GB2312,utf-8;q=0.7,*;q=0.7&quot;) #模拟浏览器头部信息 ye&lt;-c(1,seq(18,576,18)) info&lt;-NULL for(i in ye){ url&lt;-paste(&quot;https://www.douban.com/photos/ album/153818385/?start=&quot;,i,sep=&quot;&quot;) web&lt;-getURL(url,httpheader=myHttpheader) doc&lt;- htmlTreeParse(web,encoding=&quot;UTF-8&quot;, error=function(...){}, useInternalNodes = TRUE,trim=TRUE) node&lt;-getNodeSet(doc, &quot;//div[@class=&apos;photo_wrap&apos;]/a&quot;) info=c(info,sapply(node,xmlGetAttr,&quot;href&quot;)) } x&lt;-1 dir.create(&quot;E:/image1/&quot;) for(urlweb in info){ web1&lt;-getURL(urlweb,httpheader=myHttpheader) doc1&lt;- htmlTreeParse(web1,encoding=&quot;UTF-8&quot;, error=function(...){}, useInternalNodes = TRUE,trim=TRUE) node1&lt;-getNodeSet(doc1, &quot;//div[@class=&apos;photo-edit&apos;]/a&quot;) info1=sapply(node1,xmlGetAttr,&quot;href&quot;) web2&lt;-getURL(info1,httpheader=myHttpheader) doc2&lt;- htmlTreeParse(web2,encoding=&quot;UTF-8&quot;, error=function(...){}, useInternalNodes = TRUE,trim=TRUE) node2&lt;-getNodeSet(doc2, &quot;//td[@id=&apos;pic-viewer&apos;]/a/img&quot;) info2=sapply(node2,xmlGetAttr,&quot;src&quot;) y&lt;-paste(&quot;E:/image1/&quot;,x,&quot;.jpg&quot;) #创新点使用下载函数及异常处理 tryCatch({ download.file(info2,y,mode=&quot;wb&quot;) x&lt;-x+1},error=function(e){ cat(&quot;ERROR:&quot;,conditionMessage(e),&quot;\\n&quot;) print(&quot;loser&quot;)}) }","categories":[{"name":"应用案列","slug":"应用案列","permalink":"http://yoursite.com/categories/应用案列/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"},{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"}]},{"title":"基于shiny的天气查询系统","slug":"基于shiny的天气查询系统","date":"2017-04-17T08:48:50.000Z","updated":"2017-04-28T02:24:38.894Z","comments":true,"path":"2017/04/17/基于shiny的天气查询系统/","link":"","permalink":"http://yoursite.com/2017/04/17/基于shiny的天气查询系统/","excerpt":"思想很简单，基于Rvest函数制作爬虫，应用shiny搭建平台展示，源代码如下，测试本地可运行，但deploy到shinyapps出错，若你有好的思路，欢迎与我交流","text":"思想很简单，基于Rvest函数制作爬虫，应用shiny搭建平台展示，源代码如下，测试本地可运行，但deploy到shinyapps出错，若你有好的思路，欢迎与我交流 UI端： library(shiny) library(rvest) shinyUI(fluidPage( titlePanel(&quot;weather forecast&quot;), #标题 sidebarLayout( sidebarPanel( textInput(&quot;city&quot;,&quot;city:&quot;,&quot;河南 商丘 城区&quot;), actionButton(&quot;gocity&quot;, &quot;gocity&quot;), #定义按钮，点击查询天气 radioButtons(&quot;new&quot;, &quot;new:&quot;, list(&quot;true&quot; = TRUE, &quot;false&quot; = FALSE )), actionButton(&quot;updata&quot;, &quot;updata&quot;) #定义按钮，点击从中国天气网爬天气信息 ), mainPanel( tableOutput(&quot;tianqi&quot;)) #接受服务端输出 ) ) ) 服务端： library(shiny) library(rvest) shinyServer(function(input, output) { datasetInput &lt;- reactive({ df1() }) #接收按钮事件df1 observeEvent(input$gocity, { cat(&quot;Showing&quot;, input$city, &quot;\\n&quot;) }) df &lt;- eventReactive(input$gocity, { xx=datasetInput() xx[,input$city] }) # 定义查询城市的按钮事件df observeEvent(input$updata, { cat(&quot;Showing&quot;, input$new, &quot;\\n&quot;) }) df1 &lt;- eventReactive(input$updata, { web&lt;-read_html(&quot;http://www.weather.com.cn/textFC/henan.shtml&quot;,encoding=&quot;UTF-8&quot;) position&lt;-web %&gt;% html_nodes(&quot;div.conMidtab3&quot;)%&gt;%html_nodes(&quot;a&quot;)%&gt;%html_attr(&quot;href&quot;) position&lt;-na.omit(position) position&lt;-as.vector(position) position&lt;-position[!duplicated(position)] tt&lt;-list() for(i in position){ web&lt;-read_html(i,encoding = &quot;UTF-8&quot;) pos1&lt;-web%&gt;%html_nodes(&quot;div.crumbs.fl&quot;)%&gt;%html_nodes(&quot;a&quot;)%&gt;%html_text() pos2&lt;-web%&gt;%html_nodes(&quot;div.crumbs.fl&quot;)%&gt;%html_nodes(&quot;span&quot;)%&gt;%html_text() pos2&lt;-pos2[[3]] cityname&lt;-paste(pos1[[1]],pos1[[2]],pos2,sep=&quot; &quot;) tianqi&lt;-web%&gt;%html_nodes(&quot;script&quot;)%&gt;%html_text() tianqi&lt;-tianqi[[4]] rules&lt;-gregexpr(&quot;[0-9]+日[0-9]+时.{10,20}风&quot;,tianqi) tianqi&lt;-regmatches(tianqi,rules) tianqi&lt;-unlist(tianqi) tianqi&lt;-gsub(&quot;[nd][0-9][0-9],&quot;,&quot;&quot;,tianqi) tt[[cityname]]&lt;-tianqi } xx&lt;-do.call(cbind,tt) }) #定义按钮事件df1，爬虫，爬虫涉及rvest包，正则表达式，xml解析 #等内容，不在详细备注 output$tianqi &lt;- renderTable({ df() }) #接收按钮事件df，输出到ui端 }) 本地截图：","categories":[{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/categories/shiny/"}],"tags":[{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"},{"name":"shiny","slug":"shiny","permalink":"http://yoursite.com/tags/shiny/"},{"name":"实战","slug":"实战","permalink":"http://yoursite.com/tags/实战/"}]},{"title":"sklearn-K均值","slug":"sklearn-K均值","date":"2017-04-14T10:17:42.000Z","updated":"2017-04-26T10:40:21.128Z","comments":true,"path":"2017/04/14/sklearn-K均值/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-K均值/","excerpt":"如果问题中没有指定 k的值，可以通过肘部法则这一技术来估计聚类数量。肘部法则会把不同 k值的成本函数值画出来。随着 k值的增大，平均畸变程度会减小；每个类包含的样本数会减少，于是样本离其重心会更近。但是，随着 值继续增大，平均畸变程度的改善效果会不断减低。 值增大过程中，畸变程度的改善效果下降幅度最大的位置对应的 k值就是肘部。","text":"如果问题中没有指定 k的值，可以通过肘部法则这一技术来估计聚类数量。肘部法则会把不同 k值的成本函数值画出来。随着 k值的增大，平均畸变程度会减小；每个类包含的样本数会减少，于是样本离其重心会更近。但是，随着 值继续增大，平均畸变程度的改善效果会不断减低。 值增大过程中，畸变程度的改善效果下降幅度最大的位置对应的 k值就是肘部。 from sklearn.cluster import KMeans from scipy.spatial.distance import cdist import matplotlib.pyplot as plt import numpy as np import pandas as pd K=range(1,10) meandistortions=[] for k in K: kmeans=KMeans(n_clusters=k) kmeans.fit(df) meandistortions.append(sum(np.min( cdist(df,kmeans.cluster_centers_, &apos;euclidean&apos;),axis=1))/df.shape[0]) plt.plot(K,meandistortions,&apos;bx-&apos;) plt.xlabel(&apos;k&apos;) plt.show() 平均畸变程度指的是当分为两组时候，每一个样本到中心点的最小距离相加/总共的样本数 n_init: 获取初始簇中心的更迭次数 demo： df = pd.read_excel(&apos;C:/Users/Administrator/Desktop/11.xls&apos;) model= KMeans(n_clusters=2, random_state=0) model.fit(df) print model.labels_ print model.cluster_centers_ 聚类的结果评估见算法理解","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"sklearn-朴素贝叶斯","slug":"sklearn-朴素贝叶斯","date":"2017-04-14T10:14:03.000Z","updated":"2017-04-26T10:42:00.631Z","comments":true,"path":"2017/04/14/sklearn-朴素贝叶斯/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-朴素贝叶斯/","excerpt":"我们选用的朴素贝叶斯分类器类别：MultinomialNB，这个分类器以出现次数作为特征值，我们使用的TF-IDF也能符合这类分布。 其他的朴素贝叶斯分类器如GaussianNB适用于高斯分布（正态分布）的特征，而BernoulliNB适用于伯努利分布（二值分布）的特征。","text":"我们选用的朴素贝叶斯分类器类别：MultinomialNB，这个分类器以出现次数作为特征值，我们使用的TF-IDF也能符合这类分布。 其他的朴素贝叶斯分类器如GaussianNB适用于高斯分布（正态分布）的特征，而BernoulliNB适用于伯努利分布（二值分布）的特征。 import numpy as np import pandas as pd from sklearn import metrics from sklearn.naive_bayes import GaussianNB model = GaussianNB() df = pd.read_excel(&apos;C:/Users/Administrator/Desktop/11.xls&apos;) print model.fit(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) print model.score(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) predicted=model.predict(df[[&quot;mpg&quot;,&quot;wt&quot;]]) print predicted print metrics.confusion_matrix(df[[&quot;cyl&quot;]], predicted) #二分类输出概率，大于0.5设置为1，否则为0 answer = model.predict_proba(df[[&quot;mpg&quot;,&quot;wt&quot;]]) report = answer &gt; 0.5","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"sklearn-决策树","slug":"sklearn-决策树","date":"2017-04-14T10:03:16.000Z","updated":"2017-04-26T10:41:35.448Z","comments":true,"path":"2017/04/14/sklearn-决策树/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-决策树/","excerpt":"import numpy as np import pandas as pd from sklearn import tree from sklearn import metrics","text":"import numpy as np import pandas as pd from sklearn import tree from sklearn import metrics model = tree.DecisionTreeClassifier(criterion=&apos;gini&apos;) #CART算法决策树，=“entropy“表示id3算法 #model = tree.DecisionTreeRegressor()#回归决策树 df = pd.read_excel(&apos;C:/Users/Administrator/Desktop/11.xls&apos;) print model.fit(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) print model.score(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) predicted=model.predict(df[[&quot;mpg&quot;,&quot;wt&quot;]]) print metrics.confusion_matrix(df[[&quot;cyl&quot;]], predicted) #混淆矩阵 决策树的简单实现方法，不涉及前剪枝和后剪枝算法的实现： 前剪枝实现 DecisionTreeClassifier(class_weight=None, criterion=&apos;gini&apos;, max_depth=7, max_features=None, max_leaf_nodes=None, min_impurity_split=1e-07, min_samples_leaf=10, min_samples_split=20, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&apos;best&apos;) criterion: ”gini” or “entropy”(default=”gini”)是计算属性的gini(基尼不纯度)还是entropy(信息增益)，来选择最合适的节点。 splitter: ”best” or “random”(default=”best”)随机选择属性还是选择不纯度最大的属性，建议用默认。 max_features: 选择最适属性时划分的特征不能超过此值。当为整数时，即最大特征数；当为小数时，训练集特征数*小数； if “auto”, then max_features=sqrt(n_features). If “sqrt”, thenmax_features=sqrt(n_features). If “log2”, thenmax_features=log2(n_features). If None, then max_features=n_features. max_depth: (default=None)设置树的最大深度，默认为None，这样建树时，会使每一个叶节点只有一个类别，或是达到min_samples_split。 min_samples_split:根据属性划分节点时，每个划分最少的样本数。 min_samples_leaf:叶子节点最少的样本数。 max_leaf_nodes: (default=None)叶子树的最大样本数。 min_weight_fraction_leaf: (default=0) 叶子节点所需要的最小权值 后剪枝算法： Reduced-Error Pruning(REP,错误率降低剪枝): 决定是否修剪这个结点有如下步骤组成： 1：删除以此结点为根的子树 2：使其成为叶子结点 3：赋予该结点关联的训练数据的最常见分类 4：当修剪后的树对于验证集合的性能不会比原来的树差时，才真正删除该结点 从底向上的处理结点，删除那些能够最大限度的提高验证集合的精度的结点，直到会降低验证集合精度为止。 Pessimistic Error Pruning(PEP，悲观剪枝）： 先计算规则在它应用的训练样例上的精度，然后假定此估计精度为二项式分布，并计算它的标准差。对于给定的置信区间，采用下界估计作为规则性能的度量。这样做的结果，是对于大的数据集合，该剪枝策略能够非常接近观察精度，随着数据集合的减小，离观察精度越来越远。该剪枝方法尽管不是统计有效的，但是在实践中有效。","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"sklearn-LR回归","slug":"sklearn-LR回归","date":"2017-04-14T09:56:03.000Z","updated":"2017-04-26T10:40:45.621Z","comments":true,"path":"2017/04/14/sklearn-LR回归/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-LR回归/","excerpt":"原理参见算法理解模块，关于似然估计，梯度上升 import numpy as np import pandas as pd from sklearn import metrics from sklearn.linear_model import LogisticRegression","text":"原理参见算法理解模块，关于似然估计，梯度上升 import numpy as np import pandas as pd from sklearn import metrics from sklearn.linear_model import LogisticRegression model = LogisticRegression() #导入Logit回归模块 df = pd.read_excel(&apos;C:/Users/Administrator/Desktop/11.xls&apos;) #读取本地文件 print model.fit(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) #建模 print model.score(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) #输出模型的R方 print(&apos;Coefficient: n&apos;, model.coef_) #输出回归系数 print(&apos;Intercept: n&apos;, model.intercept_) #输出截距项 predicted= model.predict(df[[&quot;mpg&quot;,&quot;wt&quot;]]) #输出预测结果 print predicted print df[&quot;cyl&quot;].values print metrics.confusion_matrix(df[[&quot;cyl&quot;]], predicted) #借助metrics输出混淆矩阵 至于混淆矩阵怎么看，具体参见算法理解-分类结果的评估","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"sklearn-回归分析","slug":"sklearn-回归分析","date":"2017-04-14T09:49:55.000Z","updated":"2017-04-26T10:41:11.656Z","comments":true,"path":"2017/04/14/sklearn-回归分析/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-回归分析/","excerpt":"算法理解有回归理论和R方面的内容，再次不在详细描述 import numpy as np import pandas as pd from datetime import date, datetime from pandasql import sqldf from sklearn import linear_model from sklearn import metrics import matplotlib.pyplot as plt","text":"算法理解有回归理论和R方面的内容，再次不在详细描述 import numpy as np import pandas as pd from datetime import date, datetime from pandasql import sqldf from sklearn import linear_model from sklearn import metrics import matplotlib.pyplot as plt print datetime.today() linear = linear_model.LinearRegression() #导入模型 df = pd.read_excel(&apos;C:/Users/Administrator/ Desktop/11.xls&apos;)#读取本地数据 # print df[[&quot;mpg&quot;]] # print df[[&quot;wt&quot;]] linear.fit(df[[&quot;wt&quot;, &quot;cyl&quot;]], df[[&quot;mpg&quot;]])#建模 print &quot;R&quot;,linear.score(df[[&quot;wt&quot;, &quot;cyl&quot;]], df[[&quot;mpg&quot;]]) #输出R方 print(&apos;Coefficient: n&apos;, linear.coef_) #输出回归系数 print(&apos;Intercept: n&apos;, linear.intercept_) #输出截距项 ypred = linear.predict(df[[&quot;wt&quot;, &quot;cyl&quot;]]) #输出预测结果 print list(ypred) print &quot;MSE:&quot;, metrics.mean_squared_error (df[[&quot;mpg&quot;]], ypred) #输出均方误差 print &quot;RMSE:&quot;, np.sqrt(metrics.mean_squared_error(df[[&quot;mpg&quot;]], ypred)) #输出均方误差平方根 注意：没有输出回归系数检验，F检验的函数，没有回归四项基本假设的检验函数，没有多重共线性的检验函数。需要自己查公式写吧","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"sklearn knn算法实现","slug":"sklearn-knn算法实现","date":"2017-04-14T05:52:05.000Z","updated":"2017-04-26T10:39:47.770Z","comments":true,"path":"2017/04/14/sklearn-knn算法实现/","link":"","permalink":"http://yoursite.com/2017/04/14/sklearn-knn算法实现/","excerpt":"KNN 的计算成本很高。 变量应该先标准化（normalized），不然会被更高范围的变量偏倚。在使用KNN之前，要在野值去除和噪音去除等前期处理多花功夫。","text":"KNN 的计算成本很高。 变量应该先标准化（normalized），不然会被更高范围的变量偏倚。在使用KNN之前，要在野值去除和噪音去除等前期处理多花功夫。 from sklearn.neighbors import KNeighborsClassifier import numpy as np import pandas as pd from sklearn import metrics model=KNeighborsClassifier(n_neighbors=6) #n_neighbors=5,默认值为5，表示查询k个最近邻的数目 #algorithm=&apos;auto&apos;,指定用于计算最近邻的算法 #auto表示试图采用最适合的算法计算最近邻 df = pd.read_excel(&apos;C:/Users/Administrator/Desktop/11.xls&apos;) #读取本地文件 R语言的mtcars文件 print model.fit(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) #拟合模型 print model.score(df[[&quot;mpg&quot;,&quot;wt&quot;]], df[[&quot;cyl&quot;]]) #计算准确率 predicted=model.predict(df[[&quot;mpg&quot;,&quot;wt&quot;]]) print predicted #输出预测值 print metrics.confusion_matrix(df[[&quot;cyl&quot;]], predicted) #混淆矩阵 #给定一个空间向量，从模型中找到n个与他最近的数据 nearests = model.kneighbors([2.5,26], 6, False) print df[[&quot;mpg&quot;,&quot;wt&quot;]] print nearests #输出给定的x各个类别的概率 answer = model.predict_proba(df[[&quot;mpg&quot;,&quot;wt&quot;]]) print answer","categories":[{"name":"sklearn","slug":"sklearn","permalink":"http://yoursite.com/categories/sklearn/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"回归分析简单介绍","slug":"回归分析简单介绍","date":"2017-04-14T05:35:30.000Z","updated":"2017-04-26T10:45:14.648Z","comments":true,"path":"2017/04/14/回归分析简单介绍/","link":"","permalink":"http://yoursite.com/2017/04/14/回归分析简单介绍/","excerpt":"回归分析法是在掌握大量观察数据的基础上，利用数理统计方法建立因变量（解释变量）与自变量（响应变量）之间的回归关系函数表达式（称回归方程式）。","text":"回归分析法是在掌握大量观察数据的基础上，利用数理统计方法建立因变量（解释变量）与自变量（响应变量）之间的回归关系函数表达式（称回归方程式）。可以用来挑选与响应变量有关的解释变量，描述两者的关系，也可以生成回归方程，通过解释变量来预测响应变量。 t检验常能用作检验回归方程中各个参数的显著性， 而f检验则能用作检验整个回归关系的显著性。各解释变量联合起来对被解释变量有显著的线性关系，并不意味着每一个解释变量分别对被解释变量有显著的线性关系 最小二乘法回归分析，ols回归 最小二乘法，取一个样本点（x，y），预测数据点（x，y），则在误差平方和最小的情况下，计算模型的回归系数。 判定系数缺点，自变量越多，判断系数越大，为了调整缺点引入了调整的判断系数 回归分析法是依据事物发展变化的因果关系来预测事物未来的发展走势，它是研究变量间相互关系的一种定量预测方法，又称回归模型预测法或因果法，应用于经济预测、科技预测和企业人力资源的预测等。 ols回归的数据需要满足基本假设 正态性，对于固定的自变量值，因变量值成正态分布。残差正态分布图 独立性，Y值之间相互独立。DW检验 线性，因变量和自变量之间线性相关，线性图。 同方差性，因变量的方差不随自变量水平的不同而变化。拟合值和学生会残差的散点图，没有规则的随机分布说明满足。 lm（formula，data） coef（fit） fitted（fit） residuals（fit） anova（fit，fit） AIC（fit） plot（fit） predict（fit，data）。 多重共线性，自变量之间存在极强的相关性，使回归模型F检验通过，但回归系数t检验不通过，使模型的回归系数检验失效，模型不可信，car包vif（fit）方差膨胀因子√vif&gt;2说明存在多重共线性。可以用广义差分法消除，或box-cox变换。","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"相关与参数检验","slug":"相关与参数检验","date":"2017-04-14T05:04:09.000Z","updated":"2017-04-26T10:47:42.016Z","comments":true,"path":"2017/04/14/相关与参数检验/","link":"","permalink":"http://yoursite.com/2017/04/14/相关与参数检验/","excerpt":"相关分析 1.变量间的相关关系cor（） cor.test（x，y，alternative=） psych包 corr.test（data）","text":"相关分析 1.变量间的相关关系cor（） cor.test（x，y，alternative=） psych包 corr.test（data）2.偏相关，指控制一个或多个定量变量时，另外两个变量间的相关关系， ggm包 pcor（u，s）函数， u为协方差s里面的下表向量，前两个表示计算相关的变量，后面表示控制的变量 参数检验，需满足正态分布，结果变量为连续变量的组间比较 1.独立样本t检验 用于检验两个总体的均值相等的假设，默认假设两个总体方差不等 var.equal=True默认方差相等 t.test（y～x，data） 非独立样本t检验，（配对样本t检验） 假设组间差异呈正态分布，h0，两组样本均值之间没有显著差异 t.test（y1，y2，paired=TRUE） 多组之间的比较，方差分析 非参数检验，不服从正态分布 1.两组的比较 用来评估是否是从相同的概率分布中抽得的，既从一个总体中获得更高得分的概率是否比另一个总体要大 wilcoxon检验 wilcox.test（y～x，data） 2.多组的比较 独立样本 kruskal_wallis检验 kruskal.test（y～x，data） 非独立样本 Friedman检验 firedman.test（y～x，data）","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"EFA因子分析","slug":"EFA因子分析","date":"2017-04-14T05:00:46.000Z","updated":"2017-04-26T10:34:49.266Z","comments":true,"path":"2017/04/14/EFA因子分析/","link":"","permalink":"http://yoursite.com/2017/04/14/EFA因子分析/","excerpt":"因子分析efa x=af1+bf2….+e 发现潜在结构 主成分分析pca f1=ax1+bx2….+e 数据降纬 主成分分析是将主要成分表示为原始观察变量的线性组合，而因子分析是将原始观察变量表示为新因子的线性组合，原始观察变量在两种情况下所处的位置不同。","text":"因子分析efa x=af1+bf2….+e 发现潜在结构 主成分分析pca f1=ax1+bx2….+e 数据降纬 主成分分析是将主要成分表示为原始观察变量的线性组合，而因子分析是将原始观察变量表示为新因子的线性组合，原始观察变量在两种情况下所处的位置不同。因子分析是指研究从变量群中提取共性因子的统计技术。最早由英国心理学家C.E.斯皮尔曼提出。他发现学生的各科成绩之间存在着一定的相关性，一科成绩好的学生，往往其他各科成绩也比较好，从而推想是否存在某些潜在的共性因子，或称某些一般智力条件影响着学生的学习成绩。因子分析可在许多变量中找出隐藏的具有代表性的因子。将相同本质的变量归入一个因子，可减少变量的数目，还可检验变量间关系的假设。 步骤 1.因子载荷矩阵，a=cov（x，f）是变量和提取因子的协方差矩阵，其值越接近1，表示因子和变量的相关性越强，做方差最大旋转后可以更容易解释每个公共因子所代表的信息。强迫因子之间相互独立，斜交可以参考r实战，不做重点 2.特殊因子e，表示变量的信息丢失度。平均起来不能太大，个别也不能太大。 3.特征值和方差贡献度，累积方差贡献度，用于说明某一因子f对所有变量x的方差贡献，累积方差贡献度要大于百分之八十。信息丢失较少。 4.因子得分矩阵，pca中可以简单把某用户在第一主成分上的得分看做由他解释的变量的均值。efa中因子得分由回归法后者最小二乘法计算得到 因子分析函数r paych函数包 判断提取公因子数 fa.parallel(data，n.obs=nrow（data），n.iter=100，fa=“both”) 因子分析 fa（data，nfactors=，rotate=“varimax”，fm=“pa”，score=TRUE） fm方法参见r语言 优点：当你面对大量的数据 尤其是数据项目较多的时候，分别分析各组数据过程很繁琐。然而如果从中筛选几组数据分析，又会使得你的分析结果不够准确。 因子分析法就能很好的涵盖原始数据的各个项，同时将分析过程简化为因子项的分析。从而简便。 缺点：因子分析只能面对综合性的评价。同时对数据的数据量和成分也有要求。需要先进行KOM检测数据是否可以运用因子分析法。 而且在设计调查表的时候也需要针对性的设计问题。 我现在就在DT调查表的设计。。。。。 用处，在你对问题系统结构不了解时候，因子分析可以根据数据内在逻辑性，把它归并成几个公因子，每个公因子分别代表空间的一个维度，如果经过正交或斜 交旋转的话，各个维度之间可以认为是不相关的，这些公因子能够相对完整地刻画对象的体系维度，最起码累计方差贡献率大于85%的话，就基本能够保证重要信 息不丢失了。 注意，要先标准化处理，自变量不能为分类变量，必须为连续变量","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"svm简单介绍及实现","slug":"svm简单介绍及实现","date":"2017-04-14T04:57:50.000Z","updated":"2017-04-26T10:43:22.094Z","comments":true,"path":"2017/04/14/svm简单介绍及实现/","link":"","permalink":"http://yoursite.com/2017/04/14/svm简单介绍及实现/","excerpt":"svm是在多维空间中找到一个能将全部样本单元分成两类的最优平面，这个平面使两类中的最近点的间距最大，在间距边界的点称为支持向量，分割的超平面位于间距的中间，如果n个变量，最优超平面是n-1维的。","text":"svm是在多维空间中找到一个能将全部样本单元分成两类的最优平面，这个平面使两类中的最近点的间距最大，在间距边界的点称为支持向量，分割的超平面位于间距的中间，如果n个变量，最优超平面是n-1维的。若数据本身是非线性的，svm通过核函数将其投影到高维空间，使其在高维可分 kernlab包的ksvm和e1071包的svm函数实现 e1071 set.seed（1234） svm（formula，data）默认标准化，不能有缺失值 predict（fit，data） 带rbf核的支持向量机，将数据投影到更高维空间，面对类别标签和预测变量非线性关系效果更好 gamma控制分割超平面的形状，越大，支持向量越多，训练集到达范围越广cost犯错成本，越大表示模型对误差的惩罚越大 tune&lt;-tune.svm（formule，data， gamma=10∧（-6:1），cost=10∧（-10:10）） 拟合168个模型预测其结果选择best parameters的gamma和cost值 svm（formula，data，gamma=，cost=） 优点，适用面广，可以应用到变量数多于样本单元数的情况，可以解决小样本情况下的机器学习问题，可以解决非线性问题，可以解决高维问题 缺点，分类准则难以理解和表述，对大量样本建模时不如随机森林。不能有缺失值。","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"chaid条件推断树","slug":"chaid条件推断树","date":"2017-04-14T04:54:57.000Z","updated":"2017-04-26T10:34:00.936Z","comments":true,"path":"2017/04/14/chaid条件推断树/","link":"","permalink":"http://yoursite.com/2017/04/14/chaid条件推断树/","excerpt":"原理 先假设目标变量和自变量之间相互独立，卡方检验或者方差分析不通过，说明目标变量和自变量之间有显著影响，则该变量可作为节点，再计算相关性，相关性最强的作为本次的决策点，然后用置换检验选择决策点中最好的分割点。","text":"原理 先假设目标变量和自变量之间相互独立，卡方检验或者方差分析不通过，说明目标变量和自变量之间有显著影响，则该变量可作为节点，再计算相关性，相关性最强的作为本次的决策点，然后用置换检验选择决策点中最好的分割点。优点，计算量小。能选出来对目标变量影响高的自变量。 缺点，更容易形成臃肿的树，也更容易过度拟合。只能二分枝。 r实现，party包中 ctree（fomule，data，control=ctree.control（）） 前剪枝，无后剪枝 minsplit，minbucket，maxdepth 图 plot（fit） 预测 predict（fit，data，type=“prob”）","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"pam聚类","slug":"pam聚类","date":"2017-04-14T04:51:12.000Z","updated":"2017-04-26T10:36:24.831Z","comments":true,"path":"2017/04/14/pam聚类/","link":"","permalink":"http://yoursite.com/2017/04/14/pam聚类/","excerpt":"围绕中心点的划分 随机选取k个样本作为中心点，然后根据每个样本距离中心点最近分进不同类中，然后计算中心点到本类所有样本点的距离，接着随机选取一个非中心点的其他样本点作为中心点，计算到其他样本点的总成本，如果总成本相对于前一个中心点的减小了，则作为新中心点，再次迭代，直到中心点不再改变","text":"围绕中心点的划分 随机选取k个样本作为中心点，然后根据每个样本距离中心点最近分进不同类中，然后计算中心点到本类所有样本点的距离，接着随机选取一个非中心点的其他样本点作为中心点，计算到其他样本点的总成本，如果总成本相对于前一个中心点的减小了，则作为新中心点，再次迭代，直到中心点不再改变优缺点优点，受异常值影响较小，可以使用任意距离度量，变量可以为混合数据类型，不受变量是连续变量的限制 缺点，计算量大，不适合大型数据 set.seed（1234） fit&lt;-pam（data，k，stand=t）stand表示是否对data标准化 fit$medoids 中心点 fit$clustering 聚类情况","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"列联表分析","slug":"列联表分析","date":"2017-04-14T04:49:08.000Z","updated":"2017-04-26T10:46:34.807Z","comments":true,"path":"2017/04/14/列联表分析/","link":"","permalink":"http://yoursite.com/2017/04/14/列联表分析/","excerpt":"列联表分析 分类指标的对比 table函数 卡方检验","text":"列联表分析 分类指标的对比 table函数 卡方检验期望频率fe，实际频率f0，构建卡方统计量，研究行列分类变量直接是否有显著影响，h0，表示行列变量之间相互独立。 chisq.test（table，correct=t） 列如性别和满意度之间是否有显著影响 列联表的可视化 VCD包 mosaic（table，shade=T，legend=T）","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"re从零开始的异世界","slug":"re从零开始的异世界","date":"2017-04-13T10:44:07.000Z","updated":"2017-04-13T10:49:38.516Z","comments":true,"path":"2017/04/13/re从零开始的异世界/","link":"","permalink":"http://yoursite.com/2017/04/13/re从零开始的异世界/","excerpt":"","text":"","categories":[{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/categories/动漫/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/tags/动漫/"},{"name":"图册","slug":"图册","permalink":"http://yoursite.com/tags/图册/"}]},{"title":"序列关联算法","slug":"序列关联算法","date":"2017-04-13T10:20:55.000Z","updated":"2017-04-26T10:48:18.609Z","comments":true,"path":"2017/04/13/序列关联算法/","link":"","permalink":"http://yoursite.com/2017/04/13/序列关联算法/","excerpt":"在一组有序的数据列组成的数据集中，经常出现的那些序列组合构成的模式。跟我们所熟知的关联规则挖掘不一样，序列模式挖掘的对象以及结果都是有序的，即数据集中的每个序列的条目在时间或空间上是有序排列的，输出的结果也是有序的。","text":"在一组有序的数据列组成的数据集中，经常出现的那些序列组合构成的模式。跟我们所熟知的关联规则挖掘不一样，序列模式挖掘的对象以及结果都是有序的，即数据集中的每个序列的条目在时间或空间上是有序排列的，输出的结果也是有序的。举个简单的例子来说明，关联规则一个经典的应用是计算超市购物中被共同购买的商品，它把每个顾客的一次交易视作一个transaction，计算在不同transaction中不同item组合的规律性。而如果我们考虑一个用户多次在超市购物的情况，那么这些不同时间点的交易记录就构成了一个购买序列，N个用户的购买序列就组成一个规模为N的序列数据集。考虑这些时间上的因素之后，我们就能得到一些比关联规则更有价值的规律，比如关联挖掘经常能挖掘出如啤酒和尿布的搭配规律，而序列模式挖掘则能挖掘出诸如《育儿指南》-&gt;婴儿车这样带有一定因果性质的规律。所以，序列模式挖掘比关联挖掘能得到更深刻的知识。 序列（sequence），表示一个完整的信息流&lt;｛a，b｝，｛b｝…&gt;， 数据项（item），序列中最小单位的组合，如｛a，b｝ 事件（event），通常用时间戳来表示，表示序列中不同数据项的先后顺序 序列的包含关系，如&lt;｛a｝，｛a，c｝&gt;是&lt;｛a，b｝，｛d｝，｛a，c，d｝&gt;的子序列。 支持度，某序列x的支持度是在所有序列集合中包含x的序列频次，如&lt;｛a｝&gt;是整个序列集合的子序列，则&lt;｛a｝&gt;的支持度为n╱n=1。 序列模式关联分析指的是找出所有支持度大于min_supp的序列。 R实现，arulesSequences包的cspade函数 cspade（data，parameter=list（support），control=list（verbose=TRUE）） rule&lt;-sort（rule，by=“support”）对支持度排序 inspect（rule）","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"关联算法","slug":"关联算法","date":"2017-04-13T10:20:43.000Z","updated":"2017-04-26T10:45:04.756Z","comments":true,"path":"2017/04/13/关联算法/","link":"","permalink":"http://yoursite.com/2017/04/13/关联算法/","excerpt":"用于从数据中发现数据项之间的关系。 信任度，把购买商品1记为事件A，购买商品2记为事件B，则1=&gt;2的信任度为同时购买12的次数除以购买1的次数，衡量商品12 的关联度。confidence（item1=&gt;item2）=P（AB）╱P（A）。","text":"用于从数据中发现数据项之间的关系。 信任度，把购买商品1记为事件A，购买商品2记为事件B，则1=&gt;2的信任度为同时购买12的次数除以购买1的次数，衡量商品12 的关联度。confidence（item1=&gt;item2）=P（AB）╱P（A）。支持度，如果商品12的信任度很大，但是在总体集合中同时购买商品12的人并不多，那么信任度的结论并没有什么意义。1=&gt;2的支持度=同时购买商品12的次数除以集合总数，support（item1=&gt;item2）=P（AB）。item2本身的支持度support（item2）=P（B）。 提升度，lift（item1=&gt;item2）=confidence（item1=&gt;item2）╱support（item2）。 综上表示，如果用户不做任何推荐购买商品2的概率为support（item2），如果购买了商品1后给用户推荐2，则购买概率为confidence（item1=&gt;item2），提升度大于1，说明通过商品1推荐商品2的购买概率比未推荐前有提高。 关联分析实质上就是在集合中找到符合以下条件的关联规则 itemi=&gt;itemj。 confidence（itemi=&gt;itemj）&gt;min_cof， support（item1=&gt;item2）&gt;min_sup， 并且lift&gt;1的关联规则。 arules包里面的apriori函数 数据预处理，如果是疏散矩阵01矩阵，则 a.class&lt;-as（a.matrix，“transactions”） 如果是分类变量矩阵或数据框，不做处理。 apriori（data，parameter=list（supp，conf，target=“rules”），appearance=list（rhs=，default=“lhs”）或者appearance=list（lhs=，default=“rhs”）用来筛选关联规则）lhs，rhs表示关联规则itemi=&gt;itemj的左右两边的item。如rhs=“item3”，表示筛选出itemi=&gt;item3的规则。 inspect（rule） Python实现：http://blog.csdn.net/huruzun/article/details/40835053","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"系统聚类","slug":"系统聚类","date":"2017-04-13T10:15:42.000Z","updated":"2017-04-26T10:47:30.641Z","comments":true,"path":"2017/04/13/系统聚类/","link":"","permalink":"http://yoursite.com/2017/04/13/系统聚类/","excerpt":"1.单连接法，最短距离法，单连接方法认为，只要单个样本之间的相异度小，就认为两个组就是紧密靠拢的，而不管组间其他样本的相异度如何。这倾向于合并由一系列本身位置（原始数据集中样本的排列）靠近的样本。这种现象称为“链条”（ｃｈａｉｎｎｉｎｇ）是该方法的不足之处。故单连接方法产生的聚类可能破坏类的“紧凑性”。","text":"1.单连接法，最短距离法，单连接方法认为，只要单个样本之间的相异度小，就认为两个组就是紧密靠拢的，而不管组间其他样本的相异度如何。这倾向于合并由一系列本身位置（原始数据集中样本的排列）靠近的样本。这种现象称为“链条”（ｃｈａｉｎｎｉｎｇ）是该方法的不足之处。故单连接方法产生的聚类可能破坏类的“紧凑性”。2.完全连接法，最长距离法，类与类之间的最长距离的最短，对异常值敏感 3.离差平方和法，该方法认为，如果分类正确，同类样本的离差平方和应当较小，类与类的离差平方和应当较大。此方法类似于前面描述的几种聚类方法，都是先将ｎ个样本自成一类，此时Ｓ＝０，然后将其中两类合并成一类，即每次缩小一类。每缩小一类离差平方和Ｓ就要增大，每次都是选择使Ｓ增加最小的两类合并，直至所有的样本归为一类为止。 采用离差平方和法，样本间的距离必须采用欧氏距离。在实际应用中，离差平方和分类效果较好，应用也比较广泛，对异常值敏感 4.平均距离法，此聚类方法在定义类与类之间的距离时，既不采用两类之间的最近距离，也不采用最远距离，而是采用介于两者之间的中间距离，故该方法也称为中间距离法。它避免了最远距离与最短距离计算上的弊端 5.质心法，对异常值不是那么敏感， 聚类结果的评价 迅速评价聚类结果，在上述迭代运算中是很重要的，特别是具有高维特征向量的模式，不能直接看清聚类效果，因此，可考虑用以下几个指标来评价聚类效果： 聚类中心之间的距离 距离值大，通常可考虑分为不同类 聚类域中的样本数目 样本数目少且聚类中心距离远，可考虑是否为噪声 聚类域内样本的距离方差 方差过大的样本可考虑是否属于这一类 函数实现 data&lt;-scale（data） d&lt;-dist（data） 确定聚类数Nbclust包中的Nbclust函数 nc&lt;-Nbclust（data，distance=“euclidean”，min.nc=2， max.nc=15，method=“average”） table（nc$Best.n［1，］） 聚类函数算法实现 fit&lt;-hclust（d，method=“”） single 最短距离法，complete 完全联结法（最长距离），average 平均距离，ward 离差平方和，centroid 质心法 plot（fit） cutree（fit，k=5） 层次聚类： 优点：1，距离和规则的相似度容易定义，限制少；2，不需要预先制定聚类数；3，可以发现类的层次关系；4，可以聚类成其它形状，不限制为球状聚类，5.只能对连续变量缺点：1，计算复杂度太高；2，奇异值也能产生很大影响；3，算法很可能聚类成链状，4.不适合大数据集","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Excel函数","slug":"Excel函数","date":"2017-04-10T10:38:01.000Z","updated":"2017-04-26T10:35:20.505Z","comments":true,"path":"2017/04/10/Excel函数/","link":"","permalink":"http://yoursite.com/2017/04/10/Excel函数/","excerpt":"a$2与a2的区别，a$2：a3，前面固定 若表固定用$a$2：$f$13","text":"a$2与a2的区别，a$2：a3，前面固定 若表固定用$a$2：$f$13concatenate（a2，“”）连接多个单元格函数，“里面可以额外自写字符串” text（5％，“0％”）将百分数转换为字符可以复制或连接函数使用不会变成小数 vlookup（a表值或值，b表查询范围，返回b表第几列，精确查找0模糊1）列匹配 hlookup（值，表查询范围，返回第几列，1或0）行匹配 isnumber（）是否是数字返回t或f search（“查找的字符串”，查找位置单元格，从第几个开始查找）返回为从1开始的第一次出现的指针位置，可结合通配符？，*前面加～ int（）取整，sum（）求和，avg（）平均 随机数Rand（）生成0-1之间随机数 rand（）（b-a）a生成[a，b]之间随机数 mid（单元格，开始指针，取几个字符） Alt+d+p，数据透视表向导 Ctrl+g，定位，Ctrl+enter，一次多个数填写 Ctrl+h，替换，Ctrl+f，查找 高级筛选，分列，条件格式，选择性粘贴，数据工具。 时间函数 time（） date（year（），month（），day（）） year（），month（），day（） datedif（start，end，unit） y，m，d，yd，ym，md","categories":[{"name":"excel","slug":"excel","permalink":"http://yoursite.com/categories/excel/"}],"tags":[{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"R基础作图函数","slug":"R基础作图函数","date":"2017-04-10T10:32:20.000Z","updated":"2017-04-26T10:37:29.045Z","comments":true,"path":"2017/04/10/R基础作图函数/","link":"","permalink":"http://yoursite.com/2017/04/10/R基础作图函数/","excerpt":"第一部分 opar&lt;-par（no.readonly=T）复制当前图形配置环境，par（opar）还原。dev.new（），pch，lty，lwd，cex，col，main，xlab，ylab，xlim，ylim，title（），col╱cex╱font.axis╱main╱sub╱lab，bg后景色，fg前景色，axis（side，at，labels，lty，col，las，…）坐标轴函数配合axex=F，xaxt=“n”和yaxt=“n”使用，hmisc包里面的次要坐标轴函数minor.tick（nx，ny，tick.ratio=0.5），参考线abline（h╱v，…），abline（lm（y～x）），参考线legend（“topleft”，inset=0.5，title，c（），…），text（x，y，labels，pos），par（mfrow╱nfcol=c（）），layout（matrix，heights高度比，weights宽度比）。","text":"第一部分 opar&lt;-par（no.readonly=T）复制当前图形配置环境，par（opar）还原。dev.new（），pch，lty，lwd，cex，col，main，xlab，ylab，xlim，ylim，title（），col╱cex╱font.axis╱main╱sub╱lab，bg后景色，fg前景色，axis（side，at，labels，lty，col，las，…）坐标轴函数配合axex=F，xaxt=“n”和yaxt=“n”使用，hmisc包里面的次要坐标轴函数minor.tick（nx，ny，tick.ratio=0.5），参考线abline（h╱v，…），abline（lm（y～x）），参考线legend（“topleft”，inset=0.5，title，c（），…），text（x，y，labels，pos），par（mfrow╱nfcol=c（）），layout（matrix，heights高度比，weights宽度比）。第二部分，基本作图函数 简单条形图 barplot（vector，horiz=T水平放置） 堆砌条形图和分组条形图 barplot（matrix，col=c（“”，“”，“”），legend=rownames（matrix）标签为一个字符串向量，beside=T分组默认堆砌） 均值条形图 barplot（数值向量，names.arg=字符向量用作坐标轴标签） 棘状图 vcd包spline（matrix），显示比例情况 饼图 pie（vector，labels） 直方图 hist（vector） hist（vec，breaks=12╱vec，freq=T频数╱F密度），rug（vec，side）添加轴须图看出数据分布情况，lines（density（vec））添加核密度曲线用来观察连续变量的分布情况。 箱线图 boxplot（vec） boxplot（y～x*z，data）分组箱线图 boxplot（formula，data，notch=T加凹槽，varwidth=T使箱宽度跟样本大小成正比） 点图 dotchart（vec，labels，groups=因子vec，gcolor=“”因子标签颜色，color点颜色），x轴默认1-n补齐。 网格线 grid（nx，ny=NA） plot（），type=p画点╱i画线╱b点线╱c将b中点去掉╱h铅垂线╱s阶梯线╱n空图 lines（x，y）在plot中添加线╱曲线 线段 segments（x，y，x，y，…） 带箭头线段arrows（x，y，x，y，angle） 气泡图 Symbols（x，y，circle=r，inches=0.3）","categories":[],"tags":[{"name":"R","slug":"R","permalink":"http://yoursite.com/tags/R/"},{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"为美好的世界献上祝福","slug":"为美好的世界献上祝福图册","date":"2017-04-08T10:08:11.000Z","updated":"2017-04-08T10:50:53.149Z","comments":true,"path":"2017/04/08/为美好的世界献上祝福图册/","link":"","permalink":"http://yoursite.com/2017/04/08/为美好的世界献上祝福图册/","excerpt":"为美好的世界献上祝福，最爱的动漫-","text":"为美好的世界献上祝福，最爱的动漫-","categories":[{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/categories/动漫/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/tags/动漫/"},{"name":"图册","slug":"图册","permalink":"http://yoursite.com/tags/图册/"}]},{"title":"r字符处理函数","slug":"r字符处理函数","date":"2017-04-08T07:48:27.000Z","updated":"2017-04-28T02:18:20.136Z","comments":true,"path":"2017/04/08/r字符处理函数/","link":"","permalink":"http://yoursite.com/2017/04/08/r字符处理函数/","excerpt":"grep（pattern，vec，fixed=T╱F）在字符向量中找pattern返回找到vec［i］中存在pattern字符串的索引i向量，若fixed为F，则pattern为一个正则表达式 nchar（vec）返回字符串长度","text":"grep（pattern，vec，fixed=T╱F）在字符向量中找pattern返回找到vec［i］中存在pattern字符串的索引i向量，若fixed为F，则pattern为一个正则表达式 nchar（vec）返回字符串长度paste（“x”，1:3，sep=“.”）将字符串连接起来，x.1，x.2，x.3 substr（vec，start，end）返回一个字符串的子字符串，start，end可以为数值向量 strsplit（“2016-5-6”，split=“-”，fixed）将字符串按照split的要求分割开，2006，5，6。 regexpr（pattern，text，fixed）在字符串text中找pattern，返回他在text的第一个子字符串位置索引。 gregexpr（pattern，text，fixed）返回为查找全部子字符串的起始索引。 regmatches（data，rules） toupper（）大写转换，tolower（）小写转换。 sub（pattern，replacement，x，fixed），在x中查找pattern，用replacement替换。只查找替换第一个 gsub（pattern，replacement，x）","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"},{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"}]},{"title":"mysql数据类型","slug":"mysql数据类型","date":"2017-04-08T06:12:17.000Z","updated":"2017-04-26T10:35:53.479Z","comments":true,"path":"2017/04/08/mysql数据类型/","link":"","permalink":"http://yoursite.com/2017/04/08/mysql数据类型/","excerpt":"mysql数据类型：","text":"mysql数据类型：","categories":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"r参考卡片","slug":"r参考卡片","date":"2017-04-08T05:54:21.000Z","updated":"2017-04-26T10:38:58.964Z","comments":true,"path":"2017/04/08/r参考卡片/","link":"","permalink":"http://yoursite.com/2017/04/08/r参考卡片/","excerpt":"1.变量变换 as.array(x),as.data.frame(x),as.numeric(x), as.logical(x),as.complex(x),as.character(x), ...转换变量类型；使用如下命令可得到全部列表，methods(as) factor()：将一个向量转化为一个因子","text":"1.变量变换 as.array(x),as.data.frame(x),as.numeric(x), as.logical(x),as.complex(x),as.character(x), ...转换变量类型；使用如下命令可得到全部列表，methods(as) factor()：将一个向量转化为一个因子 2.变量信息 is.na(x),is.null(x),is.array(x),is.data.frame(x). is.numeric(x),is.complex(x),is.character (x),... 检验变量的类型；使用如下命令得到全部列表，methods(is) length(x):x中元素的个数 dim(x):查看变量的维数；重新设置的维数，例如dim(x)=c(3,2) dimnames(x):重新设置对象的名称 nrow(x):行的个数 ncol(x):列的个数 class(x):得到或设置x的类；class(x)&lt;-c(3,2) unclass(x):删除x的类 attr(x,which):得到或设置x的属性which attributes(obj):得到或设置obj的属性列表 fix,edit:对数据框数据进行表格形式的编辑 3.数据选取和操作 which.max(x):返回x中最大元素的指标 which.min(x):返回x中最小元素的指标 rev(x):翻转x中所有的元素 sort(x):升序排列x中的元素；降序排列使用：rev(sort(x)) cut(x,breaks):将x分割成为几段（或因子）；breaks为段数或分割点向量 match(x,y):返回一个和x长度相同且和y中元素相等的向量不等则返回NA which(x==a):如果比较操作为真（TRUE）,返回向量x的指针 choose(n,k):组合数的计算 na.omit(x):去除缺失值(NA)（去除相关行如果x为矩阵或数据框） na.fail(x):返回错误信息，如果x包含至少一个NA unique(x):如果x为向量或数据框，返回唯一值 table(x):返回一个由x不同值个数组成的表格（通常用于整数或因子），即频数表 subset(x,...):根据条件（...选取x中元素，如x$V1&lt;10）;如果x为数据框,选项select使用负号给出保留 或去除的变量 subset(x, subset, select, drop = FALSE, ...) sample(x,size):不放回的随即在向量x中抽取size个元素,选项replace=TRUE允许放回抽取 prop.table(x,margin=):根据margin使用分数表示表格，wumargin时，所有元素和为1 factor(x,levels=) 把向量x编码称为因子factor(x = character(), levels, labels = levels,exclude = NA, ordered = is.ordered(x)) gl() 产生因子变量gl(n,k,lenth=n*k,labels=)通过指定水平方式产生水平因子；k为水平的个数，n为重复的次数 rbind() cbind() rbind(…)以行的形式组合矩阵，数据框，或其它 cbind(…)以列的方式组合，其他同rbind() min(x):返回x中最小的元素，同max rev(x) 翻转x中的所有元素 sort(x) 升序排列x中的元素； 降序排列使用rev(sort(x)),要得到排列的小标用order() choose(n,k) 组合数计算 排列组合中的C（x, y） 从x个元素中任取y个元素的子集数目。 which() 返回满足条件的下表 sample(x,size) 不放回的随机在向量x中抽取size个元素选项 replace+TRUE允许放回抽样 rank():计算向量的秩 range(x):返回c(min(x),max(x)) sum(x):x中各元素的加和 diff(x):向量x的差分 prod(x):x中元素的连乘积 mean(x):x的均值 median(x):x的中位数 quantile(x,probs=):满足给定概率的样本分位数（默认为0,0.25,0.75,1） weight.mean(x,w):加权平均，w即为weight,即权值。 rank(x):x中元素的秩 var(x):向量x的样本方差；如果x是矩阵或数据框，协方差矩阵将被计算 cor(x):如果x是矩阵或数据框，相关系数矩阵将被计算 sd(x):x的标准差；sd(x)=sqrt(var(x)) var(x,y) or cov(x,y):x和y间的协方差；如果x,y为矩阵或数据框，返回x和y各列的协方差 cor(x,y):x和y的线性相关系数；或者相关矩阵，如果x和y为矩阵或者数据框 round(x,n):x的约数，精确到n位 log(x,base):计算x以base为基的对数，默认基为exp(1) scale(x):如果x是一个矩阵，则中心化和标准化数据； 若只标准化数据，则使用选项center=FALSE， 若只 中心化使用scale=FALSE(默认center=TRUE, scale=TRUE) pmin(x,y,...):x[i],y[i]相比较小者，组成新的向量 pmax(x,y,...):x[i],y[i]相比较大者，组成新的向量 Re(x):复数的实部 Im(x):复数的虚部 abs(x):绝对值 Arg(x):复数角度(in radians) Conj(x):共轭复数 fft(x):数组x的快速傅里叶变换 mvfft(x):矩阵x的每一列的傅里叶变换 factorial()：计算n! cumsum():cumulative sums cumprod():cumulative products D(expression(exp(x^2)),&quot;x&quot;) ：求导 integrate(function(x) x^2,0,1)：积分 注意：大多数数学函数使用逻辑参数na.rm=FALSE来指定是否移除缺失值(NA)","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[{"name":"R，数据分析","slug":"R，数据分析","permalink":"http://yoursite.com/tags/R，数据分析/"}]},{"title":"sql语句卡片","slug":"sql语句卡片","date":"2017-04-08T05:36:33.000Z","updated":"2017-04-26T10:43:00.838Z","comments":true,"path":"2017/04/08/sql语句卡片/","link":"","permalink":"http://yoursite.com/2017/04/08/sql语句卡片/","excerpt":"基本数据类型 char（），varchar（），float（m，d），decimal（m，d），int，tinyint，date，year，time，datetime，enum（）枚举，text注意tinyint（m） zerofill 0填充","text":"基本数据类型 char（），varchar（），float（m，d），decimal（m，d），int，tinyint，date，year，time，datetime，enum（）枚举，text注意tinyint（m） zerofill 0填充增删改insert into tablename（a，b，c）values（a，b，c） insert into tablenameselect语句 delete from tnmwhere 条件 update tnmset 语句where 条件 列增删改 alter table tnm add 列名 列声明 alter table tnm drop 列名 alter table tnm change oldname newname 列声明 列声明，not Null，unsigned，default 默认值，primary key，auto_increment。 创建新表 create table tnm（列1 列声明，列2，列声明） 查询语句 select 列from 表where 条件group by 列having 条件（对上面语句的结果筛选）order by 排序 desc（降序）limit a，b 条件运算函数 count，sum，avg，and，or，in（），between a and b， 通配符like ％，_，distinct 列名唯一值 % 替代一个字符或多个字符 _替代一个字符 [abc] []中的任何一个字符 [!abc] 不是[]中的任何一个字符 注意 select sum(列&lt;60)结果为满足条件的个数 from子查询 select 列 from（select 列 from 表 where 语句 ……） where 条件 …… where子查询 select 列 from 表 where 列 in（select 语句） 合并查询语句 （select 语句） union（union all） （select 语句） order by 列名 左连接（把连接后结果当做表） select 列 from t1 left join t2 as t3 on t1.ID=t2.ID left join t4 as t5 on t1.ID=t4.id where 条件 右连接right join 内连接inner join 视图view 简化查询，控制权限，大数据分表，表数据改变影响相应视图的结果，视图也能影响表，但视图不总是可以改的。create view 视图名 asselect 语句 drop view 视图名alter view as select语句 视图的algorithm=merge合并查询语句╱temptable创造临时表╱undefined系统自动确定 定义字符集charset utf-8 触发器trigger 监视增删改触发增删改，监视地点，事件，触发时间，事件 creat trigger 名字 after╱before insert╱update╱delete on 表名 （触发时间 监视事件，监视地点） for each row begin sql语句（触发事件） end 触发器引用行变量 对于insert来说，新增行用new.列名表示 creat trigger 名字 after insert on 表名 for each row begin update table set 数目=数目-new.xiadan where ID=new.gid end 对于delete来说，删除行用old表示，每一列用old.列名表示，语法同上 对于update来说，修改前用old.列名表示，修改后用new.列名表示 before先运行触发事件sql语句，再运行监视事件，列如可以控制下单数目，防止刷单。if 条件 then 语句 end if 存储引擎与事务 myisam innodb 批量插入速度 高 低 事务安全 支持 全文索引 支持 锁机制 表锁 行锁 create table 名（）engine=innodb 事务 事务指一组操作要么都完成，要么都不执行，不能撤销，一致性，隔离性 start transaction；（唯一要求加；的）sql语句；commit；提交，rollback回滚； 数据库备份与恢复 mysqldump -u 用户名 -p 密码 库名 （表名）&gt;地址╱备份文件名mysqldump -u 用户名 -p 密码 库名1 库名2&gt;地址╱备份文件名恢复source&lt;地址文件名，详细以后再看，不重要 索引 二叉树索引，hash索引，加快了查询速度，但降低了增删改速度，增加表大小 where后面列变量可以用索引，分类变量不用索引 类型，普通索引index，仅仅加快查询速度。 唯一索引unique，行上值不能重复。 主健索引primary key，主健索引是唯一索引，但唯一索引不是主健索引，主健索引只能有一个。 全文索引fulltext。 查看索引show index from 表 建立索引alter table 表 add index╱unique… ［索引名］（列名） 建立主健索引alter table 表 add primary key（列名）主健没有索引名 删除索引 alter table 表 drop index 索引名╱primary key","categories":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"R语言常用函数","slug":"R语言常用函数","date":"2017-04-08T03:13:28.000Z","updated":"2017-04-26T10:38:42.667Z","comments":true,"path":"2017/04/08/R语言常用函数/","link":"","permalink":"http://yoursite.com/2017/04/08/R语言常用函数/","excerpt":"getwd（），setwd（），help（），example（） 第一章，向量 length（），x[ ]，运算自动循环补齐，索引，％％，％╱％，其他运算，str（），attribute（），class（），mode（），seq（from，to，length，by），rep（data，time，each），all（），any（），sqrt（），ABS（），trunc（），round（x，digit），signif（x，digits），head（），tail（），quantile（x，probs），","text":"getwd（），setwd（），help（），example（） 第一章，向量 length（），x[ ]，运算自动循环补齐，索引，％％，％╱％，其他运算，str（），attribute（），class（），mode（），seq（from，to，length，by），rep（data，time，each），all（），any（），sqrt（），ABS（），trunc（），round（x，digit），signif（x，digits），head（），tail（），quantile（x，probs），sapply(vector，f），is.na（），na.rm(），na.omit（），duplicated（）找重复元素，identical（）判断两向量是否一样x$a[x$a==“”]&lt;-NA定义缺失值变量重编码类似，不再写了。x[筛选条件式]x&lt;12类似运算式返回布尔值which（条件式，arr.ind=T）返回角标，subset（data，条件，select），与或运算。names（），NULL值的应用 第二章 矩阵和数组 matrix（data，byrow，ncol，nrow，dimname=list（））％*％，矩阵索引，和向量运算时矩阵看做按列的向量，which（），cov（），cor（），row（），col（）返回矩阵，apply（data，1╱2，f（x））x为data行或者列，t（），cbind（），rbind（），dim（），z[，，drop=F]取矩阵不转向量，rownames（），colnames（）。数组array（data，c（a，b，c），dimname）索引x[a，b，c] 第三章，列表 list（a，b），索引，$和[[ ]]取一个类别为取的对象本身，[ ]取几个用类别还是list，增删改用索引选取&lt;-定义值，定义NULL为删除，c（list，list）合并列表。length（）获取列表长度，x&lt;-list（）定义空列表，列表转向量unlist（列表名），lapply（列表，f）若函数内列表为vector则强制转为list，sapply（c（list，list），f），names（），递归型列表list（a，e=list（b，c）） 第四章，数据框 data.frame（a，b，StringsAsFactors=F）索引 mt[运算式，]，类似矩阵，which（），subset（），sample（data，k，replace=），sqldf（），rbind（），cbind（），complete.cases（dataframe）返回为没一行是否有NA的布尔值，apply（），sapply（）和lapply（）把每一列看做列表，merge（x，y，by.x，by.y），order（，decrease=T），rank（），sort（），as.numeric（），as.matrix╱character╱data.frame╱factor╱logical（），as.Date（date，格式），format（date，format），difftime（s，e，units），transform（data，），str（），summary（），fix（），edit（），attach（）和detach（），cut(a,b,labels)。 第五章 因子和表 factor（data，ordered=T有序，levels，labels），unclass（），tapply（vec，factor╱list（f，f），function），split（vec╱dataframe，factor╱list（）），by（vec╱dataframe，factor，function），aggregate（data，by，function），cut（x，b，labels），table（），subtab（tn，list（行，列）），tabdom（tn，k） r语言编程结构 function（）｛｝自建函数，函数可以相互套用，函数能读取上层环境中的变量对象，超赋值只能找上层环境中赋值对象赋值。for（i in x）｛｝，while（T）｛｝break跳出循环和next跳到下一次迭代，if（）｛｝else｛｝，ifelse（x ，a，b），if（）｛｝，get（）得到对象，&amp;，|，&amp;&amp;，||，return（），print（），可用list（）存多个对象返回，formals（），body（），quote（），source（），％…％创造自己的二元运算符。 第八章，数学运算 exp（），log(10,exp(1))，log（），logx（），sqrt（），abs（），min（），pmin（），max（），pmax（），mean（），sum（），prod（），cumsum（），cumprod（），crossprod（），round（，digits），solve（a，b），solve（a），t（），eigen（），diag（）取对角线，sweep（x，1╱2，vec，运算符），向量高级运算union（x，y）交，intersect（x，y）并，setdiff（x，y），setequal（x，y），choose（x，n），％in％，combn（x，k）取子集，median（）中位数，sd（）标准差，var（）方差，mad（）绝对中位差，diff（）差分，range（）求值域。 第九第十章 ls（），rm（），exists（），scan（“文件名”，what=“”，sep=“”，encoding=“UTF-8”），readline（），scan（“”），cat（x，sep=“”╱vector），read.table（），f&lt;-file（“文件”，“r”），readLines（f，n=1）建立连接一次读一行，write.table（对象名，“存储文件名”）。 f=file（&quot;&quot;，&quot;a&quot;） writeLines（string，f） close（f） r 只读 见Python 去重： unre&lt;-re[!duplicated(re$V1),] detach(“package:RMySQL”)移除函数包 remove.packages(“RMySQL”) 删除函数包 生成时间序列向量 seq(as.Date(“2017-03-01”), by=”day”, length.out=31) 转换为unix时间戳 as.numeric(as.POSIXct(date, format=”%Y/%m/%d”)) demo：输出带分秒的时间并转换为时间戳 date&lt;-seq(as.POSIXct(strptime(“2011-03-27 01:30:00”, “%Y-%m-%d %H:%M:%S”)),by=”day”,length.out = 31)as.numeric(as.POSIXct(date, format=”%Y/%m/%d %h:%m:%s”)) 列表转矩阵 do.call(rbind,xxx) do.call(cbind,xxx) table： prop.table(table(data)) 显示频率 addmargins(mytable) 增加边际和","categories":[{"name":"R","slug":"R","permalink":"http://yoursite.com/categories/R/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"},{"name":"R语言","slug":"R语言","permalink":"http://yoursite.com/tags/R语言/"}]},{"title":"随机森林","slug":"随机森林","date":"2017-04-07T09:53:43.000Z","updated":"2017-04-26T10:46:36.766Z","comments":true,"path":"2017/04/07/随机森林/","link":"","permalink":"http://yoursite.com/2017/04/07/随机森林/","excerpt":"原理，从训练集中有放回的取出n个样本单元，形成m个训练集，在每一个节点随机抽取m个变量，作为分割该节点的候选变量，每一个节点处的变量数应一致。形成大量决策树，无需剪枝，终端节点的所属类别由节点对应众数决定，对于新样本点，应用所有决策树，选择结果的众数表示预测结果。 简单来说，随机森林就是由多棵CART（Classification And Regression Tree）构成的。对于每棵树，它们使用的训练集是从总的训练集中有放回采样出来的，这意味着，总的训练集中的有些样本可能多次出现在一棵树的训练集中，也可能从未出现在一棵树的训练集中。在训练每棵树的节点时，使用的特征是从所有特征中按照一定比例随机地无放回的抽取的，根据Leo Breiman的建议，假设总的特征数量为M，这个比例可以是sqrt(M),1/2sqrt(M),2sqrt(M)。","text":"原理，从训练集中有放回的取出n个样本单元，形成m个训练集，在每一个节点随机抽取m个变量，作为分割该节点的候选变量，每一个节点处的变量数应一致。形成大量决策树，无需剪枝，终端节点的所属类别由节点对应众数决定，对于新样本点，应用所有决策树，选择结果的众数表示预测结果。 简单来说，随机森林就是由多棵CART（Classification And Regression Tree）构成的。对于每棵树，它们使用的训练集是从总的训练集中有放回采样出来的，这意味着，总的训练集中的有些样本可能多次出现在一棵树的训练集中，也可能从未出现在一棵树的训练集中。在训练每棵树的节点时，使用的特征是从所有特征中按照一定比例随机地无放回的抽取的，根据Leo Breiman的建议，假设总的特征数量为M，这个比例可以是sqrt(M),1/2sqrt(M),2sqrt(M)。 ##因此，随机森林的训练过程可以总结如下： 1.原始训练集为N，应用bootstrap法有放回地随机抽取k个新的自助样本集，并由此构建k棵分类树，每次未被抽到的样本组成了k个袋外数据； 2.设有mall个变量，则在每一棵树的每个节点处随机抽取mtry个变量(mtry n mall)，然后在mtry中选择一个最具有分类能力的变量，变量分类的阈值通过检查每一个分类点确定, 3.每棵树最大限度地生长, 不做任何修剪； 4.将生成的多棵分类树组成随机森林，用随机森林分类器对新的数据进行判别与分类，分类结果按树分类器的投票多少而定。 在建立每一棵决策树的过程中，有两点需要注意 - 采样与完全分裂。首先是两个随机采样的过程，random forest对输入的数据要进行行、列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting。然后进行列采样，从M个feature中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。一般很多的决策树算法都一个重要的步骤 - 剪枝，但是这里不这样干，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。按这种算法得到的随机森林中的每一棵都是很弱的，但是大家组合起来就很厉害了。我觉得可以这样比喻随机森林算法：每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从M个feature中选择m让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。 ###randomForest包 set.seed（1234） randomForest（foumule，data，na.action=，importance=T…) importance（fit，type=2）#列出变量的重要度 predict（fit，data） ##优点1.在当前的很多数据集上，相对其他算法有着很大的优势，表现良好2.它能够处理很高维度（feature很多）的数据，并且不用做特征选择，特征子集是随机选择的3.在训练完后，它能够给出哪些feature比较重要4.模型泛化能力强5.在训练过程中，能够检测到feature间的互相影响6.实现比较简单7.对于不平衡的数据集来说，它可以平衡误差。8.如果有很大一部分的特征遗失，仍可以维持准确度。 ##缺点：1、随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟2、对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的。","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"时间序列分析步骤","slug":"时间序列分析步骤","date":"2017-04-07T08:28:12.000Z","updated":"2017-04-26T10:46:35.870Z","comments":true,"path":"2017/04/07/时间序列分析步骤/","link":"","permalink":"http://yoursite.com/2017/04/07/时间序列分析步骤/","excerpt":"创建时间序列 ts（data，start，end，frequency=12） xts包xts（data，date） 通过简单移动平均进行平滑处理，可以把抖动的曲线平滑化，从而弱化短期周期变化和随机变化的影响，进而更明显的显示出来长期的变化趋势。简单移动平均 y（t）=（x（t-1)+…+x（t-n））╱n","text":"创建时间序列 ts（data，start，end，frequency=12） xts包xts（data，date） 通过简单移动平均进行平滑处理，可以把抖动的曲线平滑化，从而弱化短期周期变化和随机变化的影响，进而更明显的显示出来长期的变化趋势。简单移动平均 y（t）=（x（t-1)+…+x（t-n））╱n 加权移动平均，时间越近的权重越大 s&lt;-filter（ts，c（0，1╱2，1╱2），“convolution”，sides=1） 第二部时间序列分解趋势因子，季节性因子，随机（误差）因子，想加模型，相乘模型比相加现实一点。 loess光滑做季节性分解 fit&lt;-str（log(data)，s.windom=“period”） plot（fit） 指数平滑预测法，短期预测效果良好 ets（ts，model=“”） ANN单指数模型，AAN双指数模型（Holt指数模型），AAA三指数模型forecast（fit，n） ARIMA模型自相关性acf，x［t］与他的k阶滞后序列x［td］之间是否是相关的。自相关图看几阶后不存在自相关性。 偏自相关性pacf，表示移除x［t-1］到x［t-k+1］后，x［t］与他的k阶滞后序列x［t-k］的相关性 滞后，x［t］&lt;-c（x1，…，xn），一阶滞后序列x［t-1］&lt;-c（x2，…，xn），方差相同，协方差cov（xt，xt-k）只与滞后阶数有关。 平稳时间序列，需要满足某一时间序列是由某一随机过程形成的，均值是与时间无关的常数，任何阶滞后序列的均值相同。adf平方根检验，自相关性成指数减弱，则是平稳的 白噪声序列，平稳时间序列，无自相关性，残差均值为0。 forecast包和tseries包 ndiffs（ts），返回建议差分数 diff（ts），差分 adf.test（dts），平稳性检验 Acf（），Pacf（）。 arima（ts，order），accuracy（fit）显示模型拟合优度度量指标 auto.arima（ts） qqnorm（），qqline（），对residuals残差正太检验 Box.test（fit$residuals，type=“Ljung-Box”）#自相关性是否为0的检验 forecast（fit，n） 附加截尾是指时间序列的自相关函数（ACF）或偏自相关函数（PACF）在某阶后均为0的性质（比如AR的PACF）；拖尾是ACF或PACF并不在某阶后均为0的性质（比如AR的ACF）。AR模型：自相关系数拖尾，偏自相关系数截尾；MA模型：自相关系数截尾，偏自相关函数拖尾；ARMA模型：自相关函数和偏自相关函数均拖尾。","categories":[{"name":"算法理解","slug":"算法理解","permalink":"http://yoursite.com/categories/算法理解/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]}]}